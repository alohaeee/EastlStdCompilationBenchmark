// Randomized Test types for container instantiation
// Each type has UNIQUE size and characteristics to prevent compiler optimizations
// Generated by type_randomizer.py

struct TestType1 {
    char unique_data[8];
    int id;
    float extra_field1_0[10];
    float extra_field1_1;
    char extra_field1_2[8];
    long* extra_field1_3[5];
    char random_padding[2];
    TestType1()
        : id(1), extra_field1_1(1 * 2) {
        // Initialize unique_data array
        for(int i=0; i<8; ++i) unique_data[i] = (i+1) % 256;
        for(int i=0; i<10; ++i) extra_field1_0[i] = 1 + i;
        for(int i=0; i<8; ++i) extra_field1_2[i] = 1 + i;
        for(int i=0; i<5; ++i) extra_field1_3[i] = nullptr;
        for(int i=0; i<2; ++i) random_padding[i] = (1 + i) % 128;
    }
    TestType1(const TestType1& other) {
        id = other.id + 1;
        for(int i=0; i<8; ++i) unique_data[i] = other.unique_data[i] + 1;
        for(int i=0; i<10; ++i) extra_field1_0[i] = other.extra_field1_0[i];
        extra_field1_1 = other.extra_field1_1 + 1;
        for(int i=0; i<8; ++i) extra_field1_2[i] = other.extra_field1_2[i];
        for(int i=0; i<5; ++i) extra_field1_3[i] = other.extra_field1_3[i];
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType1& operator=(const TestType1& other) {
        if(this != &other) {
            id = other.id + 1;
            for(int i=0; i<8; ++i) unique_data[i] = other.unique_data[i] + 1;
            for(int i=0; i<10; ++i) extra_field1_0[i] = other.extra_field1_0[i];
            extra_field1_1 = other.extra_field1_1 + 1;
            for(int i=0; i<8; ++i) extra_field1_2[i] = other.extra_field1_2[i];
            for(int i=0; i<5; ++i) extra_field1_3[i] = other.extra_field1_3[i];
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType1& other) const { return id < other.id; }
    bool operator==(const TestType1& other) const { return id == other.id; }
};

struct TestType2 {
    char unique_data[5];
    int id;
    char** extra_field2_0;
    TestType2()
        : id(2), extra_field2_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<5; ++i) unique_data[i] = (i+2) % 256;
    }
    TestType2(const TestType2& other) {
        id = other.id + 2;
        for(int i=0; i<5; ++i) unique_data[i] = other.unique_data[i] + 2;
        extra_field2_0 = other.extra_field2_0;  // Shallow copy pointer
    }
    TestType2& operator=(const TestType2& other) {
        if(this != &other) {
            id = other.id + 2;
            for(int i=0; i<5; ++i) unique_data[i] = other.unique_data[i] + 2;
            extra_field2_0 = other.extra_field2_0;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType2& other) const { return id < other.id; }
    bool operator==(const TestType2& other) const { return id == other.id; }
};

struct TestType3 {
    char unique_data[3];
    int id;
    unsigned short extra_field3_0;
    unsigned int extra_field3_1;
    float* extra_field3_2;
    int extra_field3_3;
    int** extra_field3_4[4];
    TestType3()
        : id(3), extra_field3_0(3 * 1), extra_field3_1(3 * 2), extra_field3_2(nullptr), extra_field3_3(3 * 4) {
        // Initialize unique_data array
        for(int i=0; i<3; ++i) unique_data[i] = (i+3) % 256;
        for(int i=0; i<4; ++i) extra_field3_4[i] = nullptr;
    }
    TestType3(const TestType3& other) {
        id = other.id + 3;
        for(int i=0; i<3; ++i) unique_data[i] = other.unique_data[i] + 3;
        extra_field3_0 = other.extra_field3_0 + 3;
        extra_field3_1 = other.extra_field3_1 + 3;
        extra_field3_2 = other.extra_field3_2;  // Shallow copy pointer
        extra_field3_3 = other.extra_field3_3 + 3;
        for(int i=0; i<4; ++i) extra_field3_4[i] = other.extra_field3_4[i];
    }
    TestType3& operator=(const TestType3& other) {
        if(this != &other) {
            id = other.id + 3;
            for(int i=0; i<3; ++i) unique_data[i] = other.unique_data[i] + 3;
            extra_field3_0 = other.extra_field3_0 + 3;
            extra_field3_1 = other.extra_field3_1 + 3;
            extra_field3_2 = other.extra_field3_2;  // Shallow copy pointer
            extra_field3_3 = other.extra_field3_3 + 3;
            for(int i=0; i<4; ++i) extra_field3_4[i] = other.extra_field3_4[i];
        }
        return *this;
    }
    bool operator<(const TestType3& other) const { return id < other.id; }
    bool operator==(const TestType3& other) const { return id == other.id; }
};

struct TestType4 {
    char unique_data[15];
    int id;
    unsigned char extra_field4_0;
    unsigned char extra_field4_1;
    void* extra_field4_2;
    long double extra_field4_3;
    long double extra_field4_4;
    double padding[5];
    TestType4()
        : id(4), extra_field4_0(4 * 1), extra_field4_1(4 * 2), extra_field4_2(nullptr), extra_field4_3(4 * 4), extra_field4_4(4 * 5) {
        // Initialize unique_data array
        for(int i=0; i<15; ++i) unique_data[i] = (i+4) % 256;
        for(int i=0; i<5; ++i) padding[i] = 4 + i * 0.1;
    }
    TestType4(const TestType4& other) {
        id = other.id + 4;
        for(int i=0; i<15; ++i) unique_data[i] = other.unique_data[i] + 4;
        extra_field4_0 = other.extra_field4_0 + 4;
        extra_field4_1 = other.extra_field4_1 + 4;
        extra_field4_2 = other.extra_field4_2;  // Shallow copy pointer
        extra_field4_3 = other.extra_field4_3 + 4;
        extra_field4_4 = other.extra_field4_4 + 4;
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType4& operator=(const TestType4& other) {
        if(this != &other) {
            id = other.id + 4;
            for(int i=0; i<15; ++i) unique_data[i] = other.unique_data[i] + 4;
            extra_field4_0 = other.extra_field4_0 + 4;
            extra_field4_1 = other.extra_field4_1 + 4;
            extra_field4_2 = other.extra_field4_2;  // Shallow copy pointer
            extra_field4_3 = other.extra_field4_3 + 4;
            extra_field4_4 = other.extra_field4_4 + 4;
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType4& other) const { return id < other.id; }
    bool operator==(const TestType4& other) const { return id == other.id; }
};

struct TestType5 {
    char unique_data[11];
    int id;
    double extra_field5_0;
    long double extra_field5_1;
    int** extra_field5_2;
    double* extra_field5_3[3];
    short extra_field5_4;
    double padding[2];
    TestType5()
        : id(5), extra_field5_0(5 * 1), extra_field5_1(5 * 2), extra_field5_2(nullptr), extra_field5_4(5 * 5) {
        // Initialize unique_data array
        for(int i=0; i<11; ++i) unique_data[i] = (i+5) % 256;
        for(int i=0; i<3; ++i) extra_field5_3[i] = nullptr;
        for(int i=0; i<2; ++i) padding[i] = 5 + i * 0.1;
    }
    TestType5(const TestType5& other) {
        id = other.id + 5;
        for(int i=0; i<11; ++i) unique_data[i] = other.unique_data[i] + 5;
        extra_field5_0 = other.extra_field5_0 + 5;
        extra_field5_1 = other.extra_field5_1 + 5;
        extra_field5_2 = other.extra_field5_2;  // Shallow copy pointer
        for(int i=0; i<3; ++i) extra_field5_3[i] = other.extra_field5_3[i];
        extra_field5_4 = other.extra_field5_4 + 5;
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType5& operator=(const TestType5& other) {
        if(this != &other) {
            id = other.id + 5;
            for(int i=0; i<11; ++i) unique_data[i] = other.unique_data[i] + 5;
            extra_field5_0 = other.extra_field5_0 + 5;
            extra_field5_1 = other.extra_field5_1 + 5;
            extra_field5_2 = other.extra_field5_2;  // Shallow copy pointer
            for(int i=0; i<3; ++i) extra_field5_3[i] = other.extra_field5_3[i];
            extra_field5_4 = other.extra_field5_4 + 5;
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType5& other) const { return id < other.id; }
    bool operator==(const TestType5& other) const { return id == other.id; }
};

struct TestType6 {
    char unique_data[23];
    int id;
    long double extra_field6_0;
    long long extra_field6_1[5];
    int* extra_field6_2[1];
    char** extra_field6_3[4];
    unsigned int extra_field6_4;
    char random_padding[7];
    TestType6()
        : id(6), extra_field6_0(6 * 1), extra_field6_4(6 * 5) {
        // Initialize unique_data array
        for(int i=0; i<23; ++i) unique_data[i] = (i+6) % 256;
        for(int i=0; i<5; ++i) extra_field6_1[i] = 6 + i;
        for(int i=0; i<1; ++i) extra_field6_2[i] = nullptr;
        for(int i=0; i<4; ++i) extra_field6_3[i] = nullptr;
        for(int i=0; i<7; ++i) random_padding[i] = (6 + i) % 128;
    }
    TestType6(const TestType6& other) {
        id = other.id + 6;
        for(int i=0; i<23; ++i) unique_data[i] = other.unique_data[i] + 6;
        extra_field6_0 = other.extra_field6_0 + 6;
        for(int i=0; i<5; ++i) extra_field6_1[i] = other.extra_field6_1[i];
        for(int i=0; i<1; ++i) extra_field6_2[i] = other.extra_field6_2[i];
        for(int i=0; i<4; ++i) extra_field6_3[i] = other.extra_field6_3[i];
        extra_field6_4 = other.extra_field6_4 + 6;
        for(int i=0; i<7; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType6& operator=(const TestType6& other) {
        if(this != &other) {
            id = other.id + 6;
            for(int i=0; i<23; ++i) unique_data[i] = other.unique_data[i] + 6;
            extra_field6_0 = other.extra_field6_0 + 6;
            for(int i=0; i<5; ++i) extra_field6_1[i] = other.extra_field6_1[i];
            for(int i=0; i<1; ++i) extra_field6_2[i] = other.extra_field6_2[i];
            for(int i=0; i<4; ++i) extra_field6_3[i] = other.extra_field6_3[i];
            extra_field6_4 = other.extra_field6_4 + 6;
            for(int i=0; i<7; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType6& other) const { return id < other.id; }
    bool operator==(const TestType6& other) const { return id == other.id; }
};

struct TestType7 {
    char unique_data[19];
    int id;
    float extra_field7_0;
    unsigned int extra_field7_1[9];
    unsigned char extra_field7_2;
    char* extra_field7_3;
    TestType7()
        : id(7), extra_field7_0(7 * 1), extra_field7_2(7 * 3), extra_field7_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<19; ++i) unique_data[i] = (i+7) % 256;
        for(int i=0; i<9; ++i) extra_field7_1[i] = 7 + i;
    }
    TestType7(const TestType7& other) {
        id = other.id + 7;
        for(int i=0; i<19; ++i) unique_data[i] = other.unique_data[i] + 7;
        extra_field7_0 = other.extra_field7_0 + 7;
        for(int i=0; i<9; ++i) extra_field7_1[i] = other.extra_field7_1[i];
        extra_field7_2 = other.extra_field7_2 + 7;
        extra_field7_3 = other.extra_field7_3;  // Shallow copy pointer
    }
    TestType7& operator=(const TestType7& other) {
        if(this != &other) {
            id = other.id + 7;
            for(int i=0; i<19; ++i) unique_data[i] = other.unique_data[i] + 7;
            extra_field7_0 = other.extra_field7_0 + 7;
            for(int i=0; i<9; ++i) extra_field7_1[i] = other.extra_field7_1[i];
            extra_field7_2 = other.extra_field7_2 + 7;
            extra_field7_3 = other.extra_field7_3;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType7& other) const { return id < other.id; }
    bool operator==(const TestType7& other) const { return id == other.id; }
};

struct TestType8 {
    char unique_data[19];
    int id;
    int** extra_field8_0[5];
    double* extra_field8_1;
    void* extra_field8_2;
    char random_padding[1];
    TestType8()
        : id(8), extra_field8_1(nullptr), extra_field8_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<19; ++i) unique_data[i] = (i+8) % 256;
        for(int i=0; i<5; ++i) extra_field8_0[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (8 + i) % 128;
    }
    TestType8(const TestType8& other) {
        id = other.id + 8;
        for(int i=0; i<19; ++i) unique_data[i] = other.unique_data[i] + 8;
        for(int i=0; i<5; ++i) extra_field8_0[i] = other.extra_field8_0[i];
        extra_field8_1 = other.extra_field8_1;  // Shallow copy pointer
        extra_field8_2 = other.extra_field8_2;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType8& operator=(const TestType8& other) {
        if(this != &other) {
            id = other.id + 8;
            for(int i=0; i<19; ++i) unique_data[i] = other.unique_data[i] + 8;
            for(int i=0; i<5; ++i) extra_field8_0[i] = other.extra_field8_0[i];
            extra_field8_1 = other.extra_field8_1;  // Shallow copy pointer
            extra_field8_2 = other.extra_field8_2;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType8& other) const { return id < other.id; }
    bool operator==(const TestType8& other) const { return id == other.id; }
};

struct TestType9 {
    char unique_data[17];
    int id;
    unsigned int extra_field9_0;
    int extra_field9_1[6];
    long long extra_field9_2;
    double extra_field9_3;
    double padding[8];
    TestType9()
        : id(9), extra_field9_0(9 * 1), extra_field9_2(9 * 3), extra_field9_3(9 * 4) {
        // Initialize unique_data array
        for(int i=0; i<17; ++i) unique_data[i] = (i+9) % 256;
        for(int i=0; i<6; ++i) extra_field9_1[i] = 9 + i;
        for(int i=0; i<8; ++i) padding[i] = 9 + i * 0.1;
    }
    TestType9(const TestType9& other) {
        id = other.id + 9;
        for(int i=0; i<17; ++i) unique_data[i] = other.unique_data[i] + 9;
        extra_field9_0 = other.extra_field9_0 + 9;
        for(int i=0; i<6; ++i) extra_field9_1[i] = other.extra_field9_1[i];
        extra_field9_2 = other.extra_field9_2 + 9;
        extra_field9_3 = other.extra_field9_3 + 9;
        for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType9& operator=(const TestType9& other) {
        if(this != &other) {
            id = other.id + 9;
            for(int i=0; i<17; ++i) unique_data[i] = other.unique_data[i] + 9;
            extra_field9_0 = other.extra_field9_0 + 9;
            for(int i=0; i<6; ++i) extra_field9_1[i] = other.extra_field9_1[i];
            extra_field9_2 = other.extra_field9_2 + 9;
            extra_field9_3 = other.extra_field9_3 + 9;
            for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType9& other) const { return id < other.id; }
    bool operator==(const TestType9& other) const { return id == other.id; }
};

struct TestType10 {
    char unique_data[28];
    int id;
    unsigned long long extra_field10_0;
    short extra_field10_1;
    char random_padding[1];
    TestType10()
        : id(10), extra_field10_0(10 * 1), extra_field10_1(10 * 2) {
        // Initialize unique_data array
        for(int i=0; i<28; ++i) unique_data[i] = (i+10) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (10 + i) % 128;
    }
    TestType10(const TestType10& other) {
        id = other.id + 10;
        for(int i=0; i<28; ++i) unique_data[i] = other.unique_data[i] + 10;
        extra_field10_0 = other.extra_field10_0 + 10;
        extra_field10_1 = other.extra_field10_1 + 10;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType10& operator=(const TestType10& other) {
        if(this != &other) {
            id = other.id + 10;
            for(int i=0; i<28; ++i) unique_data[i] = other.unique_data[i] + 10;
            extra_field10_0 = other.extra_field10_0 + 10;
            extra_field10_1 = other.extra_field10_1 + 10;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType10& other) const { return id < other.id; }
    bool operator==(const TestType10& other) const { return id == other.id; }
};

#if NUM_TYPES >= 11
struct TestType11 {
    char unique_data[30];
    int id;
    int* extra_field11_0;
    void* extra_field11_1;
    char random_padding[2];
    TestType11()
        : id(11), extra_field11_0(nullptr), extra_field11_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<30; ++i) unique_data[i] = (i+11) % 256;
        for(int i=0; i<2; ++i) random_padding[i] = (11 + i) % 128;
    }
    TestType11(const TestType11& other) {
        id = other.id + 11;
        for(int i=0; i<30; ++i) unique_data[i] = other.unique_data[i] + 11;
        extra_field11_0 = other.extra_field11_0;  // Shallow copy pointer
        extra_field11_1 = other.extra_field11_1;  // Shallow copy pointer
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType11& operator=(const TestType11& other) {
        if(this != &other) {
            id = other.id + 11;
            for(int i=0; i<30; ++i) unique_data[i] = other.unique_data[i] + 11;
            extra_field11_0 = other.extra_field11_0;  // Shallow copy pointer
            extra_field11_1 = other.extra_field11_1;  // Shallow copy pointer
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType11& other) const { return id < other.id; }
    bool operator==(const TestType11& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 12
struct TestType12 {
    char unique_data[13];
    int id;
    float extra_field12_0;
    double padding[3];
    TestType12()
        : id(12), extra_field12_0(12 * 1) {
        // Initialize unique_data array
        for(int i=0; i<13; ++i) unique_data[i] = (i+12) % 256;
        for(int i=0; i<3; ++i) padding[i] = 12 + i * 0.1;
    }
    TestType12(const TestType12& other) {
        id = other.id + 12;
        for(int i=0; i<13; ++i) unique_data[i] = other.unique_data[i] + 12;
        extra_field12_0 = other.extra_field12_0 + 12;
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType12& operator=(const TestType12& other) {
        if(this != &other) {
            id = other.id + 12;
            for(int i=0; i<13; ++i) unique_data[i] = other.unique_data[i] + 12;
            extra_field12_0 = other.extra_field12_0 + 12;
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType12& other) const { return id < other.id; }
    bool operator==(const TestType12& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 13
struct TestType13 {
    char unique_data[26];
    int id;
    long* extra_field13_0;
    char* extra_field13_1;
    char** extra_field13_2[4];
    short extra_field13_3[6];
    TestType13()
        : id(13), extra_field13_0(nullptr), extra_field13_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<26; ++i) unique_data[i] = (i+13) % 256;
        for(int i=0; i<4; ++i) extra_field13_2[i] = nullptr;
        for(int i=0; i<6; ++i) extra_field13_3[i] = 13 + i;
    }
    TestType13(const TestType13& other) {
        id = other.id + 13;
        for(int i=0; i<26; ++i) unique_data[i] = other.unique_data[i] + 13;
        extra_field13_0 = other.extra_field13_0;  // Shallow copy pointer
        extra_field13_1 = other.extra_field13_1;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field13_2[i] = other.extra_field13_2[i];
        for(int i=0; i<6; ++i) extra_field13_3[i] = other.extra_field13_3[i];
    }
    TestType13& operator=(const TestType13& other) {
        if(this != &other) {
            id = other.id + 13;
            for(int i=0; i<26; ++i) unique_data[i] = other.unique_data[i] + 13;
            extra_field13_0 = other.extra_field13_0;  // Shallow copy pointer
            extra_field13_1 = other.extra_field13_1;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field13_2[i] = other.extra_field13_2[i];
            for(int i=0; i<6; ++i) extra_field13_3[i] = other.extra_field13_3[i];
        }
        return *this;
    }
    bool operator<(const TestType13& other) const { return id < other.id; }
    bool operator==(const TestType13& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 14
struct TestType14 {
    char unique_data[34];
    int id;
    char* extra_field14_0;
    short extra_field14_1;
    double* extra_field14_2;
    char random_padding[3];
    TestType14()
        : id(14), extra_field14_0(nullptr), extra_field14_1(14 * 2), extra_field14_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<34; ++i) unique_data[i] = (i+14) % 256;
        for(int i=0; i<3; ++i) random_padding[i] = (14 + i) % 128;
    }
    TestType14(const TestType14& other) {
        id = other.id + 14;
        for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 14;
        extra_field14_0 = other.extra_field14_0;  // Shallow copy pointer
        extra_field14_1 = other.extra_field14_1 + 14;
        extra_field14_2 = other.extra_field14_2;  // Shallow copy pointer
        for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType14& operator=(const TestType14& other) {
        if(this != &other) {
            id = other.id + 14;
            for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 14;
            extra_field14_0 = other.extra_field14_0;  // Shallow copy pointer
            extra_field14_1 = other.extra_field14_1 + 14;
            extra_field14_2 = other.extra_field14_2;  // Shallow copy pointer
            for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType14& other) const { return id < other.id; }
    bool operator==(const TestType14& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 15
struct TestType15 {
    char unique_data[21];
    int id;
    unsigned long extra_field15_0[9];
    float* extra_field15_1;
    int** extra_field15_2[4];
    double padding[7];
    TestType15()
        : id(15), extra_field15_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<21; ++i) unique_data[i] = (i+15) % 256;
        for(int i=0; i<9; ++i) extra_field15_0[i] = 15 + i;
        for(int i=0; i<4; ++i) extra_field15_2[i] = nullptr;
        for(int i=0; i<7; ++i) padding[i] = 15 + i * 0.1;
    }
    TestType15(const TestType15& other) {
        id = other.id + 15;
        for(int i=0; i<21; ++i) unique_data[i] = other.unique_data[i] + 15;
        for(int i=0; i<9; ++i) extra_field15_0[i] = other.extra_field15_0[i];
        extra_field15_1 = other.extra_field15_1;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field15_2[i] = other.extra_field15_2[i];
        for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType15& operator=(const TestType15& other) {
        if(this != &other) {
            id = other.id + 15;
            for(int i=0; i<21; ++i) unique_data[i] = other.unique_data[i] + 15;
            for(int i=0; i<9; ++i) extra_field15_0[i] = other.extra_field15_0[i];
            extra_field15_1 = other.extra_field15_1;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field15_2[i] = other.extra_field15_2[i];
            for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType15& other) const { return id < other.id; }
    bool operator==(const TestType15& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 16
struct TestType16 {
    char unique_data[36];
    int id;
    long long extra_field16_0;
    long long extra_field16_1;
    char random_padding[4];
    TestType16()
        : id(16), extra_field16_0(16 * 1), extra_field16_1(16 * 2) {
        // Initialize unique_data array
        for(int i=0; i<36; ++i) unique_data[i] = (i+16) % 256;
        for(int i=0; i<4; ++i) random_padding[i] = (16 + i) % 128;
    }
    TestType16(const TestType16& other) {
        id = other.id + 16;
        for(int i=0; i<36; ++i) unique_data[i] = other.unique_data[i] + 16;
        extra_field16_0 = other.extra_field16_0 + 16;
        extra_field16_1 = other.extra_field16_1 + 16;
        for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType16& operator=(const TestType16& other) {
        if(this != &other) {
            id = other.id + 16;
            for(int i=0; i<36; ++i) unique_data[i] = other.unique_data[i] + 16;
            extra_field16_0 = other.extra_field16_0 + 16;
            extra_field16_1 = other.extra_field16_1 + 16;
            for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType16& other) const { return id < other.id; }
    bool operator==(const TestType16& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 17
struct TestType17 {
    char unique_data[26];
    int id;
    char extra_field17_0;
    unsigned int extra_field17_1;
    int extra_field17_2[8];
    double extra_field17_3[2];
    char random_padding[8];
    TestType17()
        : id(17), extra_field17_0(17 * 1), extra_field17_1(17 * 2) {
        // Initialize unique_data array
        for(int i=0; i<26; ++i) unique_data[i] = (i+17) % 256;
        for(int i=0; i<8; ++i) extra_field17_2[i] = 17 + i;
        for(int i=0; i<2; ++i) extra_field17_3[i] = 17 + i;
        for(int i=0; i<8; ++i) random_padding[i] = (17 + i) % 128;
    }
    TestType17(const TestType17& other) {
        id = other.id + 17;
        for(int i=0; i<26; ++i) unique_data[i] = other.unique_data[i] + 17;
        extra_field17_0 = other.extra_field17_0 + 17;
        extra_field17_1 = other.extra_field17_1 + 17;
        for(int i=0; i<8; ++i) extra_field17_2[i] = other.extra_field17_2[i];
        for(int i=0; i<2; ++i) extra_field17_3[i] = other.extra_field17_3[i];
        for(int i=0; i<8; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType17& operator=(const TestType17& other) {
        if(this != &other) {
            id = other.id + 17;
            for(int i=0; i<26; ++i) unique_data[i] = other.unique_data[i] + 17;
            extra_field17_0 = other.extra_field17_0 + 17;
            extra_field17_1 = other.extra_field17_1 + 17;
            for(int i=0; i<8; ++i) extra_field17_2[i] = other.extra_field17_2[i];
            for(int i=0; i<2; ++i) extra_field17_3[i] = other.extra_field17_3[i];
            for(int i=0; i<8; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType17& other) const { return id < other.id; }
    bool operator==(const TestType17& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 18
struct TestType18 {
    char unique_data[29];
    int id;
    float* extra_field18_0;
    char random_padding[8];
    TestType18()
        : id(18), extra_field18_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<29; ++i) unique_data[i] = (i+18) % 256;
        for(int i=0; i<8; ++i) random_padding[i] = (18 + i) % 128;
    }
    TestType18(const TestType18& other) {
        id = other.id + 18;
        for(int i=0; i<29; ++i) unique_data[i] = other.unique_data[i] + 18;
        extra_field18_0 = other.extra_field18_0;  // Shallow copy pointer
        for(int i=0; i<8; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType18& operator=(const TestType18& other) {
        if(this != &other) {
            id = other.id + 18;
            for(int i=0; i<29; ++i) unique_data[i] = other.unique_data[i] + 18;
            extra_field18_0 = other.extra_field18_0;  // Shallow copy pointer
            for(int i=0; i<8; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType18& other) const { return id < other.id; }
    bool operator==(const TestType18& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 19
struct TestType19 {
    char unique_data[33];
    int id;
    void* extra_field19_0;
    double* extra_field19_1;
    long* extra_field19_2;
    unsigned long extra_field19_3;
    double* extra_field19_4[3];
    double padding[5];
    TestType19()
        : id(19), extra_field19_0(nullptr), extra_field19_1(nullptr), extra_field19_2(nullptr), extra_field19_3(19 * 4) {
        // Initialize unique_data array
        for(int i=0; i<33; ++i) unique_data[i] = (i+19) % 256;
        for(int i=0; i<3; ++i) extra_field19_4[i] = nullptr;
        for(int i=0; i<5; ++i) padding[i] = 19 + i * 0.1;
    }
    TestType19(const TestType19& other) {
        id = other.id + 19;
        for(int i=0; i<33; ++i) unique_data[i] = other.unique_data[i] + 19;
        extra_field19_0 = other.extra_field19_0;  // Shallow copy pointer
        extra_field19_1 = other.extra_field19_1;  // Shallow copy pointer
        extra_field19_2 = other.extra_field19_2;  // Shallow copy pointer
        extra_field19_3 = other.extra_field19_3 + 19;
        for(int i=0; i<3; ++i) extra_field19_4[i] = other.extra_field19_4[i];
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType19& operator=(const TestType19& other) {
        if(this != &other) {
            id = other.id + 19;
            for(int i=0; i<33; ++i) unique_data[i] = other.unique_data[i] + 19;
            extra_field19_0 = other.extra_field19_0;  // Shallow copy pointer
            extra_field19_1 = other.extra_field19_1;  // Shallow copy pointer
            extra_field19_2 = other.extra_field19_2;  // Shallow copy pointer
            extra_field19_3 = other.extra_field19_3 + 19;
            for(int i=0; i<3; ++i) extra_field19_4[i] = other.extra_field19_4[i];
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType19& other) const { return id < other.id; }
    bool operator==(const TestType19& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 20
struct TestType20 {
    char unique_data[25];
    int id;
    char** extra_field20_0;
    float extra_field20_1[6];
    double padding[3];
    TestType20()
        : id(20), extra_field20_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<25; ++i) unique_data[i] = (i+20) % 256;
        for(int i=0; i<6; ++i) extra_field20_1[i] = 20 + i;
        for(int i=0; i<3; ++i) padding[i] = 20 + i * 0.1;
    }
    TestType20(const TestType20& other) {
        id = other.id + 20;
        for(int i=0; i<25; ++i) unique_data[i] = other.unique_data[i] + 20;
        extra_field20_0 = other.extra_field20_0;  // Shallow copy pointer
        for(int i=0; i<6; ++i) extra_field20_1[i] = other.extra_field20_1[i];
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType20& operator=(const TestType20& other) {
        if(this != &other) {
            id = other.id + 20;
            for(int i=0; i<25; ++i) unique_data[i] = other.unique_data[i] + 20;
            extra_field20_0 = other.extra_field20_0;  // Shallow copy pointer
            for(int i=0; i<6; ++i) extra_field20_1[i] = other.extra_field20_1[i];
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType20& other) const { return id < other.id; }
    bool operator==(const TestType20& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 21
struct TestType21 {
    char unique_data[34];
    int id;
    unsigned long long extra_field21_0;
    long* extra_field21_1;
    unsigned long long extra_field21_2;
    char* extra_field21_3[5];
    char random_padding[1];
    TestType21()
        : id(21), extra_field21_0(21 * 1), extra_field21_1(nullptr), extra_field21_2(21 * 3) {
        // Initialize unique_data array
        for(int i=0; i<34; ++i) unique_data[i] = (i+21) % 256;
        for(int i=0; i<5; ++i) extra_field21_3[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (21 + i) % 128;
    }
    TestType21(const TestType21& other) {
        id = other.id + 21;
        for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 21;
        extra_field21_0 = other.extra_field21_0 + 21;
        extra_field21_1 = other.extra_field21_1;  // Shallow copy pointer
        extra_field21_2 = other.extra_field21_2 + 21;
        for(int i=0; i<5; ++i) extra_field21_3[i] = other.extra_field21_3[i];
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType21& operator=(const TestType21& other) {
        if(this != &other) {
            id = other.id + 21;
            for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 21;
            extra_field21_0 = other.extra_field21_0 + 21;
            extra_field21_1 = other.extra_field21_1;  // Shallow copy pointer
            extra_field21_2 = other.extra_field21_2 + 21;
            for(int i=0; i<5; ++i) extra_field21_3[i] = other.extra_field21_3[i];
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType21& other) const { return id < other.id; }
    bool operator==(const TestType21& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 22
struct TestType22 {
    char unique_data[32];
    int id;
    char** extra_field22_0[3];
    unsigned char extra_field22_1;
    char* extra_field22_2[2];
    void* extra_field22_3;
    double padding[4];
    TestType22()
        : id(22), extra_field22_1(22 * 2), extra_field22_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<32; ++i) unique_data[i] = (i+22) % 256;
        for(int i=0; i<3; ++i) extra_field22_0[i] = nullptr;
        for(int i=0; i<2; ++i) extra_field22_2[i] = nullptr;
        for(int i=0; i<4; ++i) padding[i] = 22 + i * 0.1;
    }
    TestType22(const TestType22& other) {
        id = other.id + 22;
        for(int i=0; i<32; ++i) unique_data[i] = other.unique_data[i] + 22;
        for(int i=0; i<3; ++i) extra_field22_0[i] = other.extra_field22_0[i];
        extra_field22_1 = other.extra_field22_1 + 22;
        for(int i=0; i<2; ++i) extra_field22_2[i] = other.extra_field22_2[i];
        extra_field22_3 = other.extra_field22_3;  // Shallow copy pointer
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType22& operator=(const TestType22& other) {
        if(this != &other) {
            id = other.id + 22;
            for(int i=0; i<32; ++i) unique_data[i] = other.unique_data[i] + 22;
            for(int i=0; i<3; ++i) extra_field22_0[i] = other.extra_field22_0[i];
            extra_field22_1 = other.extra_field22_1 + 22;
            for(int i=0; i<2; ++i) extra_field22_2[i] = other.extra_field22_2[i];
            extra_field22_3 = other.extra_field22_3;  // Shallow copy pointer
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType22& other) const { return id < other.id; }
    bool operator==(const TestType22& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 23
struct TestType23 {
    char unique_data[30];
    int id;
    long* extra_field23_0;
    char random_padding[3];
    TestType23()
        : id(23), extra_field23_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<30; ++i) unique_data[i] = (i+23) % 256;
        for(int i=0; i<3; ++i) random_padding[i] = (23 + i) % 128;
    }
    TestType23(const TestType23& other) {
        id = other.id + 23;
        for(int i=0; i<30; ++i) unique_data[i] = other.unique_data[i] + 23;
        extra_field23_0 = other.extra_field23_0;  // Shallow copy pointer
        for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType23& operator=(const TestType23& other) {
        if(this != &other) {
            id = other.id + 23;
            for(int i=0; i<30; ++i) unique_data[i] = other.unique_data[i] + 23;
            extra_field23_0 = other.extra_field23_0;  // Shallow copy pointer
            for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType23& other) const { return id < other.id; }
    bool operator==(const TestType23& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 24
struct TestType24 {
    char unique_data[44];
    int id;
    int* extra_field24_0;
    unsigned int extra_field24_1;
    char* extra_field24_2[3];
    int* extra_field24_3;
    unsigned short extra_field24_4;
    TestType24()
        : id(24), extra_field24_0(nullptr), extra_field24_1(24 * 2), extra_field24_3(nullptr), extra_field24_4(24 * 5) {
        // Initialize unique_data array
        for(int i=0; i<44; ++i) unique_data[i] = (i+24) % 256;
        for(int i=0; i<3; ++i) extra_field24_2[i] = nullptr;
    }
    TestType24(const TestType24& other) {
        id = other.id + 24;
        for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 24;
        extra_field24_0 = other.extra_field24_0;  // Shallow copy pointer
        extra_field24_1 = other.extra_field24_1 + 24;
        for(int i=0; i<3; ++i) extra_field24_2[i] = other.extra_field24_2[i];
        extra_field24_3 = other.extra_field24_3;  // Shallow copy pointer
        extra_field24_4 = other.extra_field24_4 + 24;
    }
    TestType24& operator=(const TestType24& other) {
        if(this != &other) {
            id = other.id + 24;
            for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 24;
            extra_field24_0 = other.extra_field24_0;  // Shallow copy pointer
            extra_field24_1 = other.extra_field24_1 + 24;
            for(int i=0; i<3; ++i) extra_field24_2[i] = other.extra_field24_2[i];
            extra_field24_3 = other.extra_field24_3;  // Shallow copy pointer
            extra_field24_4 = other.extra_field24_4 + 24;
        }
        return *this;
    }
    bool operator<(const TestType24& other) const { return id < other.id; }
    bool operator==(const TestType24& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 25
struct TestType25 {
    char unique_data[25];
    int id;
    double extra_field25_0[1];
    int** extra_field25_1[4];
    char* extra_field25_2[2];
    double extra_field25_3;
    double padding[5];
    TestType25()
        : id(25), extra_field25_3(25 * 4) {
        // Initialize unique_data array
        for(int i=0; i<25; ++i) unique_data[i] = (i+25) % 256;
        for(int i=0; i<1; ++i) extra_field25_0[i] = 25 + i;
        for(int i=0; i<4; ++i) extra_field25_1[i] = nullptr;
        for(int i=0; i<2; ++i) extra_field25_2[i] = nullptr;
        for(int i=0; i<5; ++i) padding[i] = 25 + i * 0.1;
    }
    TestType25(const TestType25& other) {
        id = other.id + 25;
        for(int i=0; i<25; ++i) unique_data[i] = other.unique_data[i] + 25;
        for(int i=0; i<1; ++i) extra_field25_0[i] = other.extra_field25_0[i];
        for(int i=0; i<4; ++i) extra_field25_1[i] = other.extra_field25_1[i];
        for(int i=0; i<2; ++i) extra_field25_2[i] = other.extra_field25_2[i];
        extra_field25_3 = other.extra_field25_3 + 25;
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType25& operator=(const TestType25& other) {
        if(this != &other) {
            id = other.id + 25;
            for(int i=0; i<25; ++i) unique_data[i] = other.unique_data[i] + 25;
            for(int i=0; i<1; ++i) extra_field25_0[i] = other.extra_field25_0[i];
            for(int i=0; i<4; ++i) extra_field25_1[i] = other.extra_field25_1[i];
            for(int i=0; i<2; ++i) extra_field25_2[i] = other.extra_field25_2[i];
            extra_field25_3 = other.extra_field25_3 + 25;
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType25& other) const { return id < other.id; }
    bool operator==(const TestType25& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 26
struct TestType26 {
    char unique_data[27];
    int id;
    char** extra_field26_0[4];
    unsigned long long extra_field26_1;
    double* extra_field26_2;
    int extra_field26_3;
    TestType26()
        : id(26), extra_field26_1(26 * 2), extra_field26_2(nullptr), extra_field26_3(26 * 4) {
        // Initialize unique_data array
        for(int i=0; i<27; ++i) unique_data[i] = (i+26) % 256;
        for(int i=0; i<4; ++i) extra_field26_0[i] = nullptr;
    }
    TestType26(const TestType26& other) {
        id = other.id + 26;
        for(int i=0; i<27; ++i) unique_data[i] = other.unique_data[i] + 26;
        for(int i=0; i<4; ++i) extra_field26_0[i] = other.extra_field26_0[i];
        extra_field26_1 = other.extra_field26_1 + 26;
        extra_field26_2 = other.extra_field26_2;  // Shallow copy pointer
        extra_field26_3 = other.extra_field26_3 + 26;
    }
    TestType26& operator=(const TestType26& other) {
        if(this != &other) {
            id = other.id + 26;
            for(int i=0; i<27; ++i) unique_data[i] = other.unique_data[i] + 26;
            for(int i=0; i<4; ++i) extra_field26_0[i] = other.extra_field26_0[i];
            extra_field26_1 = other.extra_field26_1 + 26;
            extra_field26_2 = other.extra_field26_2;  // Shallow copy pointer
            extra_field26_3 = other.extra_field26_3 + 26;
        }
        return *this;
    }
    bool operator<(const TestType26& other) const { return id < other.id; }
    bool operator==(const TestType26& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 27
struct TestType27 {
    char unique_data[45];
    int id;
    long double extra_field27_0[9];
    TestType27()
        : id(27) {
        // Initialize unique_data array
        for(int i=0; i<45; ++i) unique_data[i] = (i+27) % 256;
        for(int i=0; i<9; ++i) extra_field27_0[i] = 27 + i;
    }
    TestType27(const TestType27& other) {
        id = other.id + 27;
        for(int i=0; i<45; ++i) unique_data[i] = other.unique_data[i] + 27;
        for(int i=0; i<9; ++i) extra_field27_0[i] = other.extra_field27_0[i];
    }
    TestType27& operator=(const TestType27& other) {
        if(this != &other) {
            id = other.id + 27;
            for(int i=0; i<45; ++i) unique_data[i] = other.unique_data[i] + 27;
            for(int i=0; i<9; ++i) extra_field27_0[i] = other.extra_field27_0[i];
        }
        return *this;
    }
    bool operator<(const TestType27& other) const { return id < other.id; }
    bool operator==(const TestType27& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 28
struct TestType28 {
    char unique_data[46];
    int id;
    int** extra_field28_0;
    char** extra_field28_1[1];
    double padding[4];
    TestType28()
        : id(28), extra_field28_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<46; ++i) unique_data[i] = (i+28) % 256;
        for(int i=0; i<1; ++i) extra_field28_1[i] = nullptr;
        for(int i=0; i<4; ++i) padding[i] = 28 + i * 0.1;
    }
    TestType28(const TestType28& other) {
        id = other.id + 28;
        for(int i=0; i<46; ++i) unique_data[i] = other.unique_data[i] + 28;
        extra_field28_0 = other.extra_field28_0;  // Shallow copy pointer
        for(int i=0; i<1; ++i) extra_field28_1[i] = other.extra_field28_1[i];
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType28& operator=(const TestType28& other) {
        if(this != &other) {
            id = other.id + 28;
            for(int i=0; i<46; ++i) unique_data[i] = other.unique_data[i] + 28;
            extra_field28_0 = other.extra_field28_0;  // Shallow copy pointer
            for(int i=0; i<1; ++i) extra_field28_1[i] = other.extra_field28_1[i];
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType28& other) const { return id < other.id; }
    bool operator==(const TestType28& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 29
struct TestType29 {
    char unique_data[29];
    int id;
    double* extra_field29_0[3];
    int* extra_field29_1;
    double* extra_field29_2;
    double* extra_field29_3[1];
    unsigned long long extra_field29_4[3];
    TestType29()
        : id(29), extra_field29_1(nullptr), extra_field29_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<29; ++i) unique_data[i] = (i+29) % 256;
        for(int i=0; i<3; ++i) extra_field29_0[i] = nullptr;
        for(int i=0; i<1; ++i) extra_field29_3[i] = nullptr;
        for(int i=0; i<3; ++i) extra_field29_4[i] = 29 + i;
    }
    TestType29(const TestType29& other) {
        id = other.id + 29;
        for(int i=0; i<29; ++i) unique_data[i] = other.unique_data[i] + 29;
        for(int i=0; i<3; ++i) extra_field29_0[i] = other.extra_field29_0[i];
        extra_field29_1 = other.extra_field29_1;  // Shallow copy pointer
        extra_field29_2 = other.extra_field29_2;  // Shallow copy pointer
        for(int i=0; i<1; ++i) extra_field29_3[i] = other.extra_field29_3[i];
        for(int i=0; i<3; ++i) extra_field29_4[i] = other.extra_field29_4[i];
    }
    TestType29& operator=(const TestType29& other) {
        if(this != &other) {
            id = other.id + 29;
            for(int i=0; i<29; ++i) unique_data[i] = other.unique_data[i] + 29;
            for(int i=0; i<3; ++i) extra_field29_0[i] = other.extra_field29_0[i];
            extra_field29_1 = other.extra_field29_1;  // Shallow copy pointer
            extra_field29_2 = other.extra_field29_2;  // Shallow copy pointer
            for(int i=0; i<1; ++i) extra_field29_3[i] = other.extra_field29_3[i];
            for(int i=0; i<3; ++i) extra_field29_4[i] = other.extra_field29_4[i];
        }
        return *this;
    }
    bool operator<(const TestType29& other) const { return id < other.id; }
    bool operator==(const TestType29& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 30
struct TestType30 {
    char unique_data[50];
    int id;
    int** extra_field30_0[3];
    long* extra_field30_1;
    double padding[2];
    TestType30()
        : id(30), extra_field30_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<50; ++i) unique_data[i] = (i+30) % 256;
        for(int i=0; i<3; ++i) extra_field30_0[i] = nullptr;
        for(int i=0; i<2; ++i) padding[i] = 30 + i * 0.1;
    }
    TestType30(const TestType30& other) {
        id = other.id + 30;
        for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 30;
        for(int i=0; i<3; ++i) extra_field30_0[i] = other.extra_field30_0[i];
        extra_field30_1 = other.extra_field30_1;  // Shallow copy pointer
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType30& operator=(const TestType30& other) {
        if(this != &other) {
            id = other.id + 30;
            for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 30;
            for(int i=0; i<3; ++i) extra_field30_0[i] = other.extra_field30_0[i];
            extra_field30_1 = other.extra_field30_1;  // Shallow copy pointer
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType30& other) const { return id < other.id; }
    bool operator==(const TestType30& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 31
struct TestType31 {
    char unique_data[34];
    int id;
    double extra_field31_0[10];
    double padding[2];
    TestType31()
        : id(31) {
        // Initialize unique_data array
        for(int i=0; i<34; ++i) unique_data[i] = (i+31) % 256;
        for(int i=0; i<10; ++i) extra_field31_0[i] = 31 + i;
        for(int i=0; i<2; ++i) padding[i] = 31 + i * 0.1;
    }
    TestType31(const TestType31& other) {
        id = other.id + 31;
        for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 31;
        for(int i=0; i<10; ++i) extra_field31_0[i] = other.extra_field31_0[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType31& operator=(const TestType31& other) {
        if(this != &other) {
            id = other.id + 31;
            for(int i=0; i<34; ++i) unique_data[i] = other.unique_data[i] + 31;
            for(int i=0; i<10; ++i) extra_field31_0[i] = other.extra_field31_0[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType31& other) const { return id < other.id; }
    bool operator==(const TestType31& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 32
struct TestType32 {
    char unique_data[44];
    int id;
    unsigned long long extra_field32_0[1];
    short extra_field32_1;
    float* extra_field32_2;
    long double extra_field32_3;
    unsigned int extra_field32_4[9];
    double padding[3];
    TestType32()
        : id(32), extra_field32_1(32 * 2), extra_field32_2(nullptr), extra_field32_3(32 * 4) {
        // Initialize unique_data array
        for(int i=0; i<44; ++i) unique_data[i] = (i+32) % 256;
        for(int i=0; i<1; ++i) extra_field32_0[i] = 32 + i;
        for(int i=0; i<9; ++i) extra_field32_4[i] = 32 + i;
        for(int i=0; i<3; ++i) padding[i] = 32 + i * 0.1;
    }
    TestType32(const TestType32& other) {
        id = other.id + 32;
        for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 32;
        for(int i=0; i<1; ++i) extra_field32_0[i] = other.extra_field32_0[i];
        extra_field32_1 = other.extra_field32_1 + 32;
        extra_field32_2 = other.extra_field32_2;  // Shallow copy pointer
        extra_field32_3 = other.extra_field32_3 + 32;
        for(int i=0; i<9; ++i) extra_field32_4[i] = other.extra_field32_4[i];
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType32& operator=(const TestType32& other) {
        if(this != &other) {
            id = other.id + 32;
            for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 32;
            for(int i=0; i<1; ++i) extra_field32_0[i] = other.extra_field32_0[i];
            extra_field32_1 = other.extra_field32_1 + 32;
            extra_field32_2 = other.extra_field32_2;  // Shallow copy pointer
            extra_field32_3 = other.extra_field32_3 + 32;
            for(int i=0; i<9; ++i) extra_field32_4[i] = other.extra_field32_4[i];
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType32& other) const { return id < other.id; }
    bool operator==(const TestType32& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 33
struct TestType33 {
    char unique_data[40];
    int id;
    char** extra_field33_0;
    double padding[5];
    TestType33()
        : id(33), extra_field33_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<40; ++i) unique_data[i] = (i+33) % 256;
        for(int i=0; i<5; ++i) padding[i] = 33 + i * 0.1;
    }
    TestType33(const TestType33& other) {
        id = other.id + 33;
        for(int i=0; i<40; ++i) unique_data[i] = other.unique_data[i] + 33;
        extra_field33_0 = other.extra_field33_0;  // Shallow copy pointer
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType33& operator=(const TestType33& other) {
        if(this != &other) {
            id = other.id + 33;
            for(int i=0; i<40; ++i) unique_data[i] = other.unique_data[i] + 33;
            extra_field33_0 = other.extra_field33_0;  // Shallow copy pointer
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType33& other) const { return id < other.id; }
    bool operator==(const TestType33& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 34
struct TestType34 {
    char unique_data[52];
    int id;
    double* extra_field34_0;
    void* extra_field34_1;
    long long extra_field34_2;
    unsigned long long extra_field34_3[10];
    double padding[6];
    TestType34()
        : id(34), extra_field34_0(nullptr), extra_field34_1(nullptr), extra_field34_2(34 * 3) {
        // Initialize unique_data array
        for(int i=0; i<52; ++i) unique_data[i] = (i+34) % 256;
        for(int i=0; i<10; ++i) extra_field34_3[i] = 34 + i;
        for(int i=0; i<6; ++i) padding[i] = 34 + i * 0.1;
    }
    TestType34(const TestType34& other) {
        id = other.id + 34;
        for(int i=0; i<52; ++i) unique_data[i] = other.unique_data[i] + 34;
        extra_field34_0 = other.extra_field34_0;  // Shallow copy pointer
        extra_field34_1 = other.extra_field34_1;  // Shallow copy pointer
        extra_field34_2 = other.extra_field34_2 + 34;
        for(int i=0; i<10; ++i) extra_field34_3[i] = other.extra_field34_3[i];
        for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType34& operator=(const TestType34& other) {
        if(this != &other) {
            id = other.id + 34;
            for(int i=0; i<52; ++i) unique_data[i] = other.unique_data[i] + 34;
            extra_field34_0 = other.extra_field34_0;  // Shallow copy pointer
            extra_field34_1 = other.extra_field34_1;  // Shallow copy pointer
            extra_field34_2 = other.extra_field34_2 + 34;
            for(int i=0; i<10; ++i) extra_field34_3[i] = other.extra_field34_3[i];
            for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType34& other) const { return id < other.id; }
    bool operator==(const TestType34& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 35
struct TestType35 {
    char unique_data[52];
    int id;
    char* extra_field35_0;
    char extra_field35_1;
    unsigned long extra_field35_2;
    long double extra_field35_3[2];
    TestType35()
        : id(35), extra_field35_0(nullptr), extra_field35_1(35 * 2), extra_field35_2(35 * 3) {
        // Initialize unique_data array
        for(int i=0; i<52; ++i) unique_data[i] = (i+35) % 256;
        for(int i=0; i<2; ++i) extra_field35_3[i] = 35 + i;
    }
    TestType35(const TestType35& other) {
        id = other.id + 35;
        for(int i=0; i<52; ++i) unique_data[i] = other.unique_data[i] + 35;
        extra_field35_0 = other.extra_field35_0;  // Shallow copy pointer
        extra_field35_1 = other.extra_field35_1 + 35;
        extra_field35_2 = other.extra_field35_2 + 35;
        for(int i=0; i<2; ++i) extra_field35_3[i] = other.extra_field35_3[i];
    }
    TestType35& operator=(const TestType35& other) {
        if(this != &other) {
            id = other.id + 35;
            for(int i=0; i<52; ++i) unique_data[i] = other.unique_data[i] + 35;
            extra_field35_0 = other.extra_field35_0;  // Shallow copy pointer
            extra_field35_1 = other.extra_field35_1 + 35;
            extra_field35_2 = other.extra_field35_2 + 35;
            for(int i=0; i<2; ++i) extra_field35_3[i] = other.extra_field35_3[i];
        }
        return *this;
    }
    bool operator<(const TestType35& other) const { return id < other.id; }
    bool operator==(const TestType35& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 36
struct TestType36 {
    char unique_data[47];
    int id;
    unsigned int extra_field36_0;
    double padding[7];
    TestType36()
        : id(36), extra_field36_0(36 * 1) {
        // Initialize unique_data array
        for(int i=0; i<47; ++i) unique_data[i] = (i+36) % 256;
        for(int i=0; i<7; ++i) padding[i] = 36 + i * 0.1;
    }
    TestType36(const TestType36& other) {
        id = other.id + 36;
        for(int i=0; i<47; ++i) unique_data[i] = other.unique_data[i] + 36;
        extra_field36_0 = other.extra_field36_0 + 36;
        for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType36& operator=(const TestType36& other) {
        if(this != &other) {
            id = other.id + 36;
            for(int i=0; i<47; ++i) unique_data[i] = other.unique_data[i] + 36;
            extra_field36_0 = other.extra_field36_0 + 36;
            for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType36& other) const { return id < other.id; }
    bool operator==(const TestType36& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 37
struct TestType37 {
    char unique_data[47];
    int id;
    int** extra_field37_0[1];
    char** extra_field37_1[1];
    double padding[3];
    TestType37()
        : id(37) {
        // Initialize unique_data array
        for(int i=0; i<47; ++i) unique_data[i] = (i+37) % 256;
        for(int i=0; i<1; ++i) extra_field37_0[i] = nullptr;
        for(int i=0; i<1; ++i) extra_field37_1[i] = nullptr;
        for(int i=0; i<3; ++i) padding[i] = 37 + i * 0.1;
    }
    TestType37(const TestType37& other) {
        id = other.id + 37;
        for(int i=0; i<47; ++i) unique_data[i] = other.unique_data[i] + 37;
        for(int i=0; i<1; ++i) extra_field37_0[i] = other.extra_field37_0[i];
        for(int i=0; i<1; ++i) extra_field37_1[i] = other.extra_field37_1[i];
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType37& operator=(const TestType37& other) {
        if(this != &other) {
            id = other.id + 37;
            for(int i=0; i<47; ++i) unique_data[i] = other.unique_data[i] + 37;
            for(int i=0; i<1; ++i) extra_field37_0[i] = other.extra_field37_0[i];
            for(int i=0; i<1; ++i) extra_field37_1[i] = other.extra_field37_1[i];
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType37& other) const { return id < other.id; }
    bool operator==(const TestType37& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 38
struct TestType38 {
    char unique_data[38];
    int id;
    int extra_field38_0;
    long extra_field38_1;
    unsigned long long extra_field38_2[10];
    long* extra_field38_3;
    char random_padding[5];
    TestType38()
        : id(38), extra_field38_0(38 * 1), extra_field38_1(38 * 2), extra_field38_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<38; ++i) unique_data[i] = (i+38) % 256;
        for(int i=0; i<10; ++i) extra_field38_2[i] = 38 + i;
        for(int i=0; i<5; ++i) random_padding[i] = (38 + i) % 128;
    }
    TestType38(const TestType38& other) {
        id = other.id + 38;
        for(int i=0; i<38; ++i) unique_data[i] = other.unique_data[i] + 38;
        extra_field38_0 = other.extra_field38_0 + 38;
        extra_field38_1 = other.extra_field38_1 + 38;
        for(int i=0; i<10; ++i) extra_field38_2[i] = other.extra_field38_2[i];
        extra_field38_3 = other.extra_field38_3;  // Shallow copy pointer
        for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType38& operator=(const TestType38& other) {
        if(this != &other) {
            id = other.id + 38;
            for(int i=0; i<38; ++i) unique_data[i] = other.unique_data[i] + 38;
            extra_field38_0 = other.extra_field38_0 + 38;
            extra_field38_1 = other.extra_field38_1 + 38;
            for(int i=0; i<10; ++i) extra_field38_2[i] = other.extra_field38_2[i];
            extra_field38_3 = other.extra_field38_3;  // Shallow copy pointer
            for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType38& other) const { return id < other.id; }
    bool operator==(const TestType38& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 39
struct TestType39 {
    char unique_data[44];
    int id;
    char* extra_field39_0[3];
    double* extra_field39_1[5];
    int extra_field39_2;
    int extra_field39_3;
    char random_padding[10];
    TestType39()
        : id(39), extra_field39_2(39 * 3), extra_field39_3(39 * 4) {
        // Initialize unique_data array
        for(int i=0; i<44; ++i) unique_data[i] = (i+39) % 256;
        for(int i=0; i<3; ++i) extra_field39_0[i] = nullptr;
        for(int i=0; i<5; ++i) extra_field39_1[i] = nullptr;
        for(int i=0; i<10; ++i) random_padding[i] = (39 + i) % 128;
    }
    TestType39(const TestType39& other) {
        id = other.id + 39;
        for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 39;
        for(int i=0; i<3; ++i) extra_field39_0[i] = other.extra_field39_0[i];
        for(int i=0; i<5; ++i) extra_field39_1[i] = other.extra_field39_1[i];
        extra_field39_2 = other.extra_field39_2 + 39;
        extra_field39_3 = other.extra_field39_3 + 39;
        for(int i=0; i<10; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType39& operator=(const TestType39& other) {
        if(this != &other) {
            id = other.id + 39;
            for(int i=0; i<44; ++i) unique_data[i] = other.unique_data[i] + 39;
            for(int i=0; i<3; ++i) extra_field39_0[i] = other.extra_field39_0[i];
            for(int i=0; i<5; ++i) extra_field39_1[i] = other.extra_field39_1[i];
            extra_field39_2 = other.extra_field39_2 + 39;
            extra_field39_3 = other.extra_field39_3 + 39;
            for(int i=0; i<10; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType39& other) const { return id < other.id; }
    bool operator==(const TestType39& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 40
struct TestType40 {
    char unique_data[49];
    int id;
    double* extra_field40_0[2];
    char random_padding[1];
    TestType40()
        : id(40) {
        // Initialize unique_data array
        for(int i=0; i<49; ++i) unique_data[i] = (i+40) % 256;
        for(int i=0; i<2; ++i) extra_field40_0[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (40 + i) % 128;
    }
    TestType40(const TestType40& other) {
        id = other.id + 40;
        for(int i=0; i<49; ++i) unique_data[i] = other.unique_data[i] + 40;
        for(int i=0; i<2; ++i) extra_field40_0[i] = other.extra_field40_0[i];
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType40& operator=(const TestType40& other) {
        if(this != &other) {
            id = other.id + 40;
            for(int i=0; i<49; ++i) unique_data[i] = other.unique_data[i] + 40;
            for(int i=0; i<2; ++i) extra_field40_0[i] = other.extra_field40_0[i];
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType40& other) const { return id < other.id; }
    bool operator==(const TestType40& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 41
struct TestType41 {
    char unique_data[50];
    int id;
    char* extra_field41_0;
    double padding[2];
    TestType41()
        : id(41), extra_field41_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<50; ++i) unique_data[i] = (i+41) % 256;
        for(int i=0; i<2; ++i) padding[i] = 41 + i * 0.1;
    }
    TestType41(const TestType41& other) {
        id = other.id + 41;
        for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 41;
        extra_field41_0 = other.extra_field41_0;  // Shallow copy pointer
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType41& operator=(const TestType41& other) {
        if(this != &other) {
            id = other.id + 41;
            for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 41;
            extra_field41_0 = other.extra_field41_0;  // Shallow copy pointer
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType41& other) const { return id < other.id; }
    bool operator==(const TestType41& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 42
struct TestType42 {
    char unique_data[43];
    int id;
    int extra_field42_0;
    float* extra_field42_1[1];
    unsigned short extra_field42_2;
    double extra_field42_3;
    char extra_field42_4[6];
    char random_padding[1];
    TestType42()
        : id(42), extra_field42_0(42 * 1), extra_field42_2(42 * 3), extra_field42_3(42 * 4) {
        // Initialize unique_data array
        for(int i=0; i<43; ++i) unique_data[i] = (i+42) % 256;
        for(int i=0; i<1; ++i) extra_field42_1[i] = nullptr;
        for(int i=0; i<6; ++i) extra_field42_4[i] = 42 + i;
        for(int i=0; i<1; ++i) random_padding[i] = (42 + i) % 128;
    }
    TestType42(const TestType42& other) {
        id = other.id + 42;
        for(int i=0; i<43; ++i) unique_data[i] = other.unique_data[i] + 42;
        extra_field42_0 = other.extra_field42_0 + 42;
        for(int i=0; i<1; ++i) extra_field42_1[i] = other.extra_field42_1[i];
        extra_field42_2 = other.extra_field42_2 + 42;
        extra_field42_3 = other.extra_field42_3 + 42;
        for(int i=0; i<6; ++i) extra_field42_4[i] = other.extra_field42_4[i];
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType42& operator=(const TestType42& other) {
        if(this != &other) {
            id = other.id + 42;
            for(int i=0; i<43; ++i) unique_data[i] = other.unique_data[i] + 42;
            extra_field42_0 = other.extra_field42_0 + 42;
            for(int i=0; i<1; ++i) extra_field42_1[i] = other.extra_field42_1[i];
            extra_field42_2 = other.extra_field42_2 + 42;
            extra_field42_3 = other.extra_field42_3 + 42;
            for(int i=0; i<6; ++i) extra_field42_4[i] = other.extra_field42_4[i];
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType42& other) const { return id < other.id; }
    bool operator==(const TestType42& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 43
struct TestType43 {
    char unique_data[46];
    int id;
    long* extra_field43_0[2];
    short extra_field43_1;
    float extra_field43_2[7];
    short extra_field43_3[8];
    char random_padding[1];
    TestType43()
        : id(43), extra_field43_1(43 * 2) {
        // Initialize unique_data array
        for(int i=0; i<46; ++i) unique_data[i] = (i+43) % 256;
        for(int i=0; i<2; ++i) extra_field43_0[i] = nullptr;
        for(int i=0; i<7; ++i) extra_field43_2[i] = 43 + i;
        for(int i=0; i<8; ++i) extra_field43_3[i] = 43 + i;
        for(int i=0; i<1; ++i) random_padding[i] = (43 + i) % 128;
    }
    TestType43(const TestType43& other) {
        id = other.id + 43;
        for(int i=0; i<46; ++i) unique_data[i] = other.unique_data[i] + 43;
        for(int i=0; i<2; ++i) extra_field43_0[i] = other.extra_field43_0[i];
        extra_field43_1 = other.extra_field43_1 + 43;
        for(int i=0; i<7; ++i) extra_field43_2[i] = other.extra_field43_2[i];
        for(int i=0; i<8; ++i) extra_field43_3[i] = other.extra_field43_3[i];
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType43& operator=(const TestType43& other) {
        if(this != &other) {
            id = other.id + 43;
            for(int i=0; i<46; ++i) unique_data[i] = other.unique_data[i] + 43;
            for(int i=0; i<2; ++i) extra_field43_0[i] = other.extra_field43_0[i];
            extra_field43_1 = other.extra_field43_1 + 43;
            for(int i=0; i<7; ++i) extra_field43_2[i] = other.extra_field43_2[i];
            for(int i=0; i<8; ++i) extra_field43_3[i] = other.extra_field43_3[i];
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType43& other) const { return id < other.id; }
    bool operator==(const TestType43& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 44
struct TestType44 {
    char unique_data[45];
    int id;
    unsigned long extra_field44_0[9];
    float* extra_field44_1;
    char random_padding[4];
    TestType44()
        : id(44), extra_field44_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<45; ++i) unique_data[i] = (i+44) % 256;
        for(int i=0; i<9; ++i) extra_field44_0[i] = 44 + i;
        for(int i=0; i<4; ++i) random_padding[i] = (44 + i) % 128;
    }
    TestType44(const TestType44& other) {
        id = other.id + 44;
        for(int i=0; i<45; ++i) unique_data[i] = other.unique_data[i] + 44;
        for(int i=0; i<9; ++i) extra_field44_0[i] = other.extra_field44_0[i];
        extra_field44_1 = other.extra_field44_1;  // Shallow copy pointer
        for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType44& operator=(const TestType44& other) {
        if(this != &other) {
            id = other.id + 44;
            for(int i=0; i<45; ++i) unique_data[i] = other.unique_data[i] + 44;
            for(int i=0; i<9; ++i) extra_field44_0[i] = other.extra_field44_0[i];
            extra_field44_1 = other.extra_field44_1;  // Shallow copy pointer
            for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType44& other) const { return id < other.id; }
    bool operator==(const TestType44& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 45
struct TestType45 {
    char unique_data[56];
    int id;
    unsigned short extra_field45_0[4];
    float* extra_field45_1[5];
    TestType45()
        : id(45) {
        // Initialize unique_data array
        for(int i=0; i<56; ++i) unique_data[i] = (i+45) % 256;
        for(int i=0; i<4; ++i) extra_field45_0[i] = 45 + i;
        for(int i=0; i<5; ++i) extra_field45_1[i] = nullptr;
    }
    TestType45(const TestType45& other) {
        id = other.id + 45;
        for(int i=0; i<56; ++i) unique_data[i] = other.unique_data[i] + 45;
        for(int i=0; i<4; ++i) extra_field45_0[i] = other.extra_field45_0[i];
        for(int i=0; i<5; ++i) extra_field45_1[i] = other.extra_field45_1[i];
    }
    TestType45& operator=(const TestType45& other) {
        if(this != &other) {
            id = other.id + 45;
            for(int i=0; i<56; ++i) unique_data[i] = other.unique_data[i] + 45;
            for(int i=0; i<4; ++i) extra_field45_0[i] = other.extra_field45_0[i];
            for(int i=0; i<5; ++i) extra_field45_1[i] = other.extra_field45_1[i];
        }
        return *this;
    }
    bool operator<(const TestType45& other) const { return id < other.id; }
    bool operator==(const TestType45& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 46
struct TestType46 {
    char unique_data[49];
    int id;
    void* extra_field46_0;
    double extra_field46_1[4];
    double padding[2];
    TestType46()
        : id(46), extra_field46_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<49; ++i) unique_data[i] = (i+46) % 256;
        for(int i=0; i<4; ++i) extra_field46_1[i] = 46 + i;
        for(int i=0; i<2; ++i) padding[i] = 46 + i * 0.1;
    }
    TestType46(const TestType46& other) {
        id = other.id + 46;
        for(int i=0; i<49; ++i) unique_data[i] = other.unique_data[i] + 46;
        extra_field46_0 = other.extra_field46_0;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field46_1[i] = other.extra_field46_1[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType46& operator=(const TestType46& other) {
        if(this != &other) {
            id = other.id + 46;
            for(int i=0; i<49; ++i) unique_data[i] = other.unique_data[i] + 46;
            extra_field46_0 = other.extra_field46_0;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field46_1[i] = other.extra_field46_1[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType46& other) const { return id < other.id; }
    bool operator==(const TestType46& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 47
struct TestType47 {
    char unique_data[61];
    int id;
    unsigned int extra_field47_0[4];
    unsigned long extra_field47_1[2];
    long extra_field47_2;
    double padding[3];
    TestType47()
        : id(47), extra_field47_2(47 * 3) {
        // Initialize unique_data array
        for(int i=0; i<61; ++i) unique_data[i] = (i+47) % 256;
        for(int i=0; i<4; ++i) extra_field47_0[i] = 47 + i;
        for(int i=0; i<2; ++i) extra_field47_1[i] = 47 + i;
        for(int i=0; i<3; ++i) padding[i] = 47 + i * 0.1;
    }
    TestType47(const TestType47& other) {
        id = other.id + 47;
        for(int i=0; i<61; ++i) unique_data[i] = other.unique_data[i] + 47;
        for(int i=0; i<4; ++i) extra_field47_0[i] = other.extra_field47_0[i];
        for(int i=0; i<2; ++i) extra_field47_1[i] = other.extra_field47_1[i];
        extra_field47_2 = other.extra_field47_2 + 47;
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType47& operator=(const TestType47& other) {
        if(this != &other) {
            id = other.id + 47;
            for(int i=0; i<61; ++i) unique_data[i] = other.unique_data[i] + 47;
            for(int i=0; i<4; ++i) extra_field47_0[i] = other.extra_field47_0[i];
            for(int i=0; i<2; ++i) extra_field47_1[i] = other.extra_field47_1[i];
            extra_field47_2 = other.extra_field47_2 + 47;
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType47& other) const { return id < other.id; }
    bool operator==(const TestType47& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 48
struct TestType48 {
    char unique_data[62];
    int id;
    unsigned char extra_field48_0;
    double padding[4];
    TestType48()
        : id(48), extra_field48_0(48 * 1) {
        // Initialize unique_data array
        for(int i=0; i<62; ++i) unique_data[i] = (i+48) % 256;
        for(int i=0; i<4; ++i) padding[i] = 48 + i * 0.1;
    }
    TestType48(const TestType48& other) {
        id = other.id + 48;
        for(int i=0; i<62; ++i) unique_data[i] = other.unique_data[i] + 48;
        extra_field48_0 = other.extra_field48_0 + 48;
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType48& operator=(const TestType48& other) {
        if(this != &other) {
            id = other.id + 48;
            for(int i=0; i<62; ++i) unique_data[i] = other.unique_data[i] + 48;
            extra_field48_0 = other.extra_field48_0 + 48;
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType48& other) const { return id < other.id; }
    bool operator==(const TestType48& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 49
struct TestType49 {
    char unique_data[66];
    int id;
    char* extra_field49_0[5];
    unsigned int extra_field49_1[4];
    long* extra_field49_2;
    double padding[5];
    TestType49()
        : id(49), extra_field49_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<66; ++i) unique_data[i] = (i+49) % 256;
        for(int i=0; i<5; ++i) extra_field49_0[i] = nullptr;
        for(int i=0; i<4; ++i) extra_field49_1[i] = 49 + i;
        for(int i=0; i<5; ++i) padding[i] = 49 + i * 0.1;
    }
    TestType49(const TestType49& other) {
        id = other.id + 49;
        for(int i=0; i<66; ++i) unique_data[i] = other.unique_data[i] + 49;
        for(int i=0; i<5; ++i) extra_field49_0[i] = other.extra_field49_0[i];
        for(int i=0; i<4; ++i) extra_field49_1[i] = other.extra_field49_1[i];
        extra_field49_2 = other.extra_field49_2;  // Shallow copy pointer
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType49& operator=(const TestType49& other) {
        if(this != &other) {
            id = other.id + 49;
            for(int i=0; i<66; ++i) unique_data[i] = other.unique_data[i] + 49;
            for(int i=0; i<5; ++i) extra_field49_0[i] = other.extra_field49_0[i];
            for(int i=0; i<4; ++i) extra_field49_1[i] = other.extra_field49_1[i];
            extra_field49_2 = other.extra_field49_2;  // Shallow copy pointer
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType49& other) const { return id < other.id; }
    bool operator==(const TestType49& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 50
struct TestType50 {
    char unique_data[50];
    int id;
    int** extra_field50_0[3];
    unsigned int extra_field50_1;
    int** extra_field50_2;
    int** extra_field50_3;
    char random_padding[1];
    TestType50()
        : id(50), extra_field50_1(50 * 2), extra_field50_2(nullptr), extra_field50_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<50; ++i) unique_data[i] = (i+50) % 256;
        for(int i=0; i<3; ++i) extra_field50_0[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (50 + i) % 128;
    }
    TestType50(const TestType50& other) {
        id = other.id + 50;
        for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 50;
        for(int i=0; i<3; ++i) extra_field50_0[i] = other.extra_field50_0[i];
        extra_field50_1 = other.extra_field50_1 + 50;
        extra_field50_2 = other.extra_field50_2;  // Shallow copy pointer
        extra_field50_3 = other.extra_field50_3;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType50& operator=(const TestType50& other) {
        if(this != &other) {
            id = other.id + 50;
            for(int i=0; i<50; ++i) unique_data[i] = other.unique_data[i] + 50;
            for(int i=0; i<3; ++i) extra_field50_0[i] = other.extra_field50_0[i];
            extra_field50_1 = other.extra_field50_1 + 50;
            extra_field50_2 = other.extra_field50_2;  // Shallow copy pointer
            extra_field50_3 = other.extra_field50_3;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType50& other) const { return id < other.id; }
    bool operator==(const TestType50& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 51
struct TestType51 {
    char unique_data[68];
    int id;
    int extra_field51_0;
    char random_padding[1];
    TestType51()
        : id(51), extra_field51_0(51 * 1) {
        // Initialize unique_data array
        for(int i=0; i<68; ++i) unique_data[i] = (i+51) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (51 + i) % 128;
    }
    TestType51(const TestType51& other) {
        id = other.id + 51;
        for(int i=0; i<68; ++i) unique_data[i] = other.unique_data[i] + 51;
        extra_field51_0 = other.extra_field51_0 + 51;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType51& operator=(const TestType51& other) {
        if(this != &other) {
            id = other.id + 51;
            for(int i=0; i<68; ++i) unique_data[i] = other.unique_data[i] + 51;
            extra_field51_0 = other.extra_field51_0 + 51;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType51& other) const { return id < other.id; }
    bool operator==(const TestType51& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 52
struct TestType52 {
    char unique_data[58];
    int id;
    double* extra_field52_0;
    float extra_field52_1[5];
    long long extra_field52_2[4];
    unsigned long extra_field52_3[2];
    double padding[6];
    TestType52()
        : id(52), extra_field52_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<58; ++i) unique_data[i] = (i+52) % 256;
        for(int i=0; i<5; ++i) extra_field52_1[i] = 52 + i;
        for(int i=0; i<4; ++i) extra_field52_2[i] = 52 + i;
        for(int i=0; i<2; ++i) extra_field52_3[i] = 52 + i;
        for(int i=0; i<6; ++i) padding[i] = 52 + i * 0.1;
    }
    TestType52(const TestType52& other) {
        id = other.id + 52;
        for(int i=0; i<58; ++i) unique_data[i] = other.unique_data[i] + 52;
        extra_field52_0 = other.extra_field52_0;  // Shallow copy pointer
        for(int i=0; i<5; ++i) extra_field52_1[i] = other.extra_field52_1[i];
        for(int i=0; i<4; ++i) extra_field52_2[i] = other.extra_field52_2[i];
        for(int i=0; i<2; ++i) extra_field52_3[i] = other.extra_field52_3[i];
        for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType52& operator=(const TestType52& other) {
        if(this != &other) {
            id = other.id + 52;
            for(int i=0; i<58; ++i) unique_data[i] = other.unique_data[i] + 52;
            extra_field52_0 = other.extra_field52_0;  // Shallow copy pointer
            for(int i=0; i<5; ++i) extra_field52_1[i] = other.extra_field52_1[i];
            for(int i=0; i<4; ++i) extra_field52_2[i] = other.extra_field52_2[i];
            for(int i=0; i<2; ++i) extra_field52_3[i] = other.extra_field52_3[i];
            for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType52& other) const { return id < other.id; }
    bool operator==(const TestType52& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 53
struct TestType53 {
    char unique_data[65];
    int id;
    int* extra_field53_0[2];
    unsigned long extra_field53_1;
    short extra_field53_2;
    char** extra_field53_3;
    double padding[4];
    TestType53()
        : id(53), extra_field53_1(53 * 2), extra_field53_2(53 * 3), extra_field53_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<65; ++i) unique_data[i] = (i+53) % 256;
        for(int i=0; i<2; ++i) extra_field53_0[i] = nullptr;
        for(int i=0; i<4; ++i) padding[i] = 53 + i * 0.1;
    }
    TestType53(const TestType53& other) {
        id = other.id + 53;
        for(int i=0; i<65; ++i) unique_data[i] = other.unique_data[i] + 53;
        for(int i=0; i<2; ++i) extra_field53_0[i] = other.extra_field53_0[i];
        extra_field53_1 = other.extra_field53_1 + 53;
        extra_field53_2 = other.extra_field53_2 + 53;
        extra_field53_3 = other.extra_field53_3;  // Shallow copy pointer
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType53& operator=(const TestType53& other) {
        if(this != &other) {
            id = other.id + 53;
            for(int i=0; i<65; ++i) unique_data[i] = other.unique_data[i] + 53;
            for(int i=0; i<2; ++i) extra_field53_0[i] = other.extra_field53_0[i];
            extra_field53_1 = other.extra_field53_1 + 53;
            extra_field53_2 = other.extra_field53_2 + 53;
            extra_field53_3 = other.extra_field53_3;  // Shallow copy pointer
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType53& other) const { return id < other.id; }
    bool operator==(const TestType53& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 54
struct TestType54 {
    char unique_data[55];
    int id;
    unsigned long long extra_field54_0;
    double* extra_field54_1;
    float extra_field54_2[8];
    float extra_field54_3[5];
    char extra_field54_4;
    TestType54()
        : id(54), extra_field54_0(54 * 1), extra_field54_1(nullptr), extra_field54_4(54 * 5) {
        // Initialize unique_data array
        for(int i=0; i<55; ++i) unique_data[i] = (i+54) % 256;
        for(int i=0; i<8; ++i) extra_field54_2[i] = 54 + i;
        for(int i=0; i<5; ++i) extra_field54_3[i] = 54 + i;
    }
    TestType54(const TestType54& other) {
        id = other.id + 54;
        for(int i=0; i<55; ++i) unique_data[i] = other.unique_data[i] + 54;
        extra_field54_0 = other.extra_field54_0 + 54;
        extra_field54_1 = other.extra_field54_1;  // Shallow copy pointer
        for(int i=0; i<8; ++i) extra_field54_2[i] = other.extra_field54_2[i];
        for(int i=0; i<5; ++i) extra_field54_3[i] = other.extra_field54_3[i];
        extra_field54_4 = other.extra_field54_4 + 54;
    }
    TestType54& operator=(const TestType54& other) {
        if(this != &other) {
            id = other.id + 54;
            for(int i=0; i<55; ++i) unique_data[i] = other.unique_data[i] + 54;
            extra_field54_0 = other.extra_field54_0 + 54;
            extra_field54_1 = other.extra_field54_1;  // Shallow copy pointer
            for(int i=0; i<8; ++i) extra_field54_2[i] = other.extra_field54_2[i];
            for(int i=0; i<5; ++i) extra_field54_3[i] = other.extra_field54_3[i];
            extra_field54_4 = other.extra_field54_4 + 54;
        }
        return *this;
    }
    bool operator<(const TestType54& other) const { return id < other.id; }
    bool operator==(const TestType54& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 55
struct TestType55 {
    char unique_data[73];
    int id;
    unsigned short extra_field55_0[10];
    long* extra_field55_1[1];
    long double extra_field55_2;
    char* extra_field55_3[2];
    double padding[7];
    TestType55()
        : id(55), extra_field55_2(55 * 3) {
        // Initialize unique_data array
        for(int i=0; i<73; ++i) unique_data[i] = (i+55) % 256;
        for(int i=0; i<10; ++i) extra_field55_0[i] = 55 + i;
        for(int i=0; i<1; ++i) extra_field55_1[i] = nullptr;
        for(int i=0; i<2; ++i) extra_field55_3[i] = nullptr;
        for(int i=0; i<7; ++i) padding[i] = 55 + i * 0.1;
    }
    TestType55(const TestType55& other) {
        id = other.id + 55;
        for(int i=0; i<73; ++i) unique_data[i] = other.unique_data[i] + 55;
        for(int i=0; i<10; ++i) extra_field55_0[i] = other.extra_field55_0[i];
        for(int i=0; i<1; ++i) extra_field55_1[i] = other.extra_field55_1[i];
        extra_field55_2 = other.extra_field55_2 + 55;
        for(int i=0; i<2; ++i) extra_field55_3[i] = other.extra_field55_3[i];
        for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType55& operator=(const TestType55& other) {
        if(this != &other) {
            id = other.id + 55;
            for(int i=0; i<73; ++i) unique_data[i] = other.unique_data[i] + 55;
            for(int i=0; i<10; ++i) extra_field55_0[i] = other.extra_field55_0[i];
            for(int i=0; i<1; ++i) extra_field55_1[i] = other.extra_field55_1[i];
            extra_field55_2 = other.extra_field55_2 + 55;
            for(int i=0; i<2; ++i) extra_field55_3[i] = other.extra_field55_3[i];
            for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType55& other) const { return id < other.id; }
    bool operator==(const TestType55& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 56
struct TestType56 {
    char unique_data[60];
    int id;
    unsigned long extra_field56_0;
    unsigned char extra_field56_1;
    char random_padding[3];
    TestType56()
        : id(56), extra_field56_0(56 * 1), extra_field56_1(56 * 2) {
        // Initialize unique_data array
        for(int i=0; i<60; ++i) unique_data[i] = (i+56) % 256;
        for(int i=0; i<3; ++i) random_padding[i] = (56 + i) % 128;
    }
    TestType56(const TestType56& other) {
        id = other.id + 56;
        for(int i=0; i<60; ++i) unique_data[i] = other.unique_data[i] + 56;
        extra_field56_0 = other.extra_field56_0 + 56;
        extra_field56_1 = other.extra_field56_1 + 56;
        for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType56& operator=(const TestType56& other) {
        if(this != &other) {
            id = other.id + 56;
            for(int i=0; i<60; ++i) unique_data[i] = other.unique_data[i] + 56;
            extra_field56_0 = other.extra_field56_0 + 56;
            extra_field56_1 = other.extra_field56_1 + 56;
            for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType56& other) const { return id < other.id; }
    bool operator==(const TestType56& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 57
struct TestType57 {
    char unique_data[62];
    int id;
    float* extra_field57_0[5];
    long long extra_field57_1;
    long extra_field57_2;
    int* extra_field57_3;
    float* extra_field57_4;
    TestType57()
        : id(57), extra_field57_1(57 * 2), extra_field57_2(57 * 3), extra_field57_3(nullptr), extra_field57_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<62; ++i) unique_data[i] = (i+57) % 256;
        for(int i=0; i<5; ++i) extra_field57_0[i] = nullptr;
    }
    TestType57(const TestType57& other) {
        id = other.id + 57;
        for(int i=0; i<62; ++i) unique_data[i] = other.unique_data[i] + 57;
        for(int i=0; i<5; ++i) extra_field57_0[i] = other.extra_field57_0[i];
        extra_field57_1 = other.extra_field57_1 + 57;
        extra_field57_2 = other.extra_field57_2 + 57;
        extra_field57_3 = other.extra_field57_3;  // Shallow copy pointer
        extra_field57_4 = other.extra_field57_4;  // Shallow copy pointer
    }
    TestType57& operator=(const TestType57& other) {
        if(this != &other) {
            id = other.id + 57;
            for(int i=0; i<62; ++i) unique_data[i] = other.unique_data[i] + 57;
            for(int i=0; i<5; ++i) extra_field57_0[i] = other.extra_field57_0[i];
            extra_field57_1 = other.extra_field57_1 + 57;
            extra_field57_2 = other.extra_field57_2 + 57;
            extra_field57_3 = other.extra_field57_3;  // Shallow copy pointer
            extra_field57_4 = other.extra_field57_4;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType57& other) const { return id < other.id; }
    bool operator==(const TestType57& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 58
struct TestType58 {
    char unique_data[74];
    int id;
    short extra_field58_0;
    long* extra_field58_1;
    TestType58()
        : id(58), extra_field58_0(58 * 1), extra_field58_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<74; ++i) unique_data[i] = (i+58) % 256;
    }
    TestType58(const TestType58& other) {
        id = other.id + 58;
        for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 58;
        extra_field58_0 = other.extra_field58_0 + 58;
        extra_field58_1 = other.extra_field58_1;  // Shallow copy pointer
    }
    TestType58& operator=(const TestType58& other) {
        if(this != &other) {
            id = other.id + 58;
            for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 58;
            extra_field58_0 = other.extra_field58_0 + 58;
            extra_field58_1 = other.extra_field58_1;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType58& other) const { return id < other.id; }
    bool operator==(const TestType58& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 59
struct TestType59 {
    char unique_data[79];
    int id;
    unsigned char extra_field59_0;
    int* extra_field59_1[5];
    int* extra_field59_2;
    unsigned long extra_field59_3;
    unsigned long long extra_field59_4[7];
    char random_padding[1];
    TestType59()
        : id(59), extra_field59_0(59 * 1), extra_field59_2(nullptr), extra_field59_3(59 * 4) {
        // Initialize unique_data array
        for(int i=0; i<79; ++i) unique_data[i] = (i+59) % 256;
        for(int i=0; i<5; ++i) extra_field59_1[i] = nullptr;
        for(int i=0; i<7; ++i) extra_field59_4[i] = 59 + i;
        for(int i=0; i<1; ++i) random_padding[i] = (59 + i) % 128;
    }
    TestType59(const TestType59& other) {
        id = other.id + 59;
        for(int i=0; i<79; ++i) unique_data[i] = other.unique_data[i] + 59;
        extra_field59_0 = other.extra_field59_0 + 59;
        for(int i=0; i<5; ++i) extra_field59_1[i] = other.extra_field59_1[i];
        extra_field59_2 = other.extra_field59_2;  // Shallow copy pointer
        extra_field59_3 = other.extra_field59_3 + 59;
        for(int i=0; i<7; ++i) extra_field59_4[i] = other.extra_field59_4[i];
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType59& operator=(const TestType59& other) {
        if(this != &other) {
            id = other.id + 59;
            for(int i=0; i<79; ++i) unique_data[i] = other.unique_data[i] + 59;
            extra_field59_0 = other.extra_field59_0 + 59;
            for(int i=0; i<5; ++i) extra_field59_1[i] = other.extra_field59_1[i];
            extra_field59_2 = other.extra_field59_2;  // Shallow copy pointer
            extra_field59_3 = other.extra_field59_3 + 59;
            for(int i=0; i<7; ++i) extra_field59_4[i] = other.extra_field59_4[i];
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType59& other) const { return id < other.id; }
    bool operator==(const TestType59& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 60
struct TestType60 {
    char unique_data[74];
    int id;
    long long extra_field60_0;
    short extra_field60_1;
    short extra_field60_2;
    long double extra_field60_3;
    char random_padding[1];
    TestType60()
        : id(60), extra_field60_0(60 * 1), extra_field60_1(60 * 2), extra_field60_2(60 * 3), extra_field60_3(60 * 4) {
        // Initialize unique_data array
        for(int i=0; i<74; ++i) unique_data[i] = (i+60) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (60 + i) % 128;
    }
    TestType60(const TestType60& other) {
        id = other.id + 60;
        for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 60;
        extra_field60_0 = other.extra_field60_0 + 60;
        extra_field60_1 = other.extra_field60_1 + 60;
        extra_field60_2 = other.extra_field60_2 + 60;
        extra_field60_3 = other.extra_field60_3 + 60;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType60& operator=(const TestType60& other) {
        if(this != &other) {
            id = other.id + 60;
            for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 60;
            extra_field60_0 = other.extra_field60_0 + 60;
            extra_field60_1 = other.extra_field60_1 + 60;
            extra_field60_2 = other.extra_field60_2 + 60;
            extra_field60_3 = other.extra_field60_3 + 60;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType60& other) const { return id < other.id; }
    bool operator==(const TestType60& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 61
struct TestType61 {
    char unique_data[65];
    int id;
    unsigned long long extra_field61_0;
    int* extra_field61_1;
    char random_padding[2];
    TestType61()
        : id(61), extra_field61_0(61 * 1), extra_field61_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<65; ++i) unique_data[i] = (i+61) % 256;
        for(int i=0; i<2; ++i) random_padding[i] = (61 + i) % 128;
    }
    TestType61(const TestType61& other) {
        id = other.id + 61;
        for(int i=0; i<65; ++i) unique_data[i] = other.unique_data[i] + 61;
        extra_field61_0 = other.extra_field61_0 + 61;
        extra_field61_1 = other.extra_field61_1;  // Shallow copy pointer
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType61& operator=(const TestType61& other) {
        if(this != &other) {
            id = other.id + 61;
            for(int i=0; i<65; ++i) unique_data[i] = other.unique_data[i] + 61;
            extra_field61_0 = other.extra_field61_0 + 61;
            extra_field61_1 = other.extra_field61_1;  // Shallow copy pointer
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType61& other) const { return id < other.id; }
    bool operator==(const TestType61& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 62
struct TestType62 {
    char unique_data[69];
    int id;
    double extra_field62_0[10];
    double* extra_field62_1;
    double padding[3];
    TestType62()
        : id(62), extra_field62_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<69; ++i) unique_data[i] = (i+62) % 256;
        for(int i=0; i<10; ++i) extra_field62_0[i] = 62 + i;
        for(int i=0; i<3; ++i) padding[i] = 62 + i * 0.1;
    }
    TestType62(const TestType62& other) {
        id = other.id + 62;
        for(int i=0; i<69; ++i) unique_data[i] = other.unique_data[i] + 62;
        for(int i=0; i<10; ++i) extra_field62_0[i] = other.extra_field62_0[i];
        extra_field62_1 = other.extra_field62_1;  // Shallow copy pointer
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType62& operator=(const TestType62& other) {
        if(this != &other) {
            id = other.id + 62;
            for(int i=0; i<69; ++i) unique_data[i] = other.unique_data[i] + 62;
            for(int i=0; i<10; ++i) extra_field62_0[i] = other.extra_field62_0[i];
            extra_field62_1 = other.extra_field62_1;  // Shallow copy pointer
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType62& other) const { return id < other.id; }
    bool operator==(const TestType62& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 63
struct TestType63 {
    char unique_data[77];
    int id;
    double* extra_field63_0;
    short extra_field63_1;
    unsigned short extra_field63_2[3];
    TestType63()
        : id(63), extra_field63_0(nullptr), extra_field63_1(63 * 2) {
        // Initialize unique_data array
        for(int i=0; i<77; ++i) unique_data[i] = (i+63) % 256;
        for(int i=0; i<3; ++i) extra_field63_2[i] = 63 + i;
    }
    TestType63(const TestType63& other) {
        id = other.id + 63;
        for(int i=0; i<77; ++i) unique_data[i] = other.unique_data[i] + 63;
        extra_field63_0 = other.extra_field63_0;  // Shallow copy pointer
        extra_field63_1 = other.extra_field63_1 + 63;
        for(int i=0; i<3; ++i) extra_field63_2[i] = other.extra_field63_2[i];
    }
    TestType63& operator=(const TestType63& other) {
        if(this != &other) {
            id = other.id + 63;
            for(int i=0; i<77; ++i) unique_data[i] = other.unique_data[i] + 63;
            extra_field63_0 = other.extra_field63_0;  // Shallow copy pointer
            extra_field63_1 = other.extra_field63_1 + 63;
            for(int i=0; i<3; ++i) extra_field63_2[i] = other.extra_field63_2[i];
        }
        return *this;
    }
    bool operator<(const TestType63& other) const { return id < other.id; }
    bool operator==(const TestType63& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 64
struct TestType64 {
    char unique_data[64];
    int id;
    int** extra_field64_0[2];
    long long extra_field64_1;
    char random_padding[1];
    TestType64()
        : id(64), extra_field64_1(64 * 2) {
        // Initialize unique_data array
        for(int i=0; i<64; ++i) unique_data[i] = (i+64) % 256;
        for(int i=0; i<2; ++i) extra_field64_0[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (64 + i) % 128;
    }
    TestType64(const TestType64& other) {
        id = other.id + 64;
        for(int i=0; i<64; ++i) unique_data[i] = other.unique_data[i] + 64;
        for(int i=0; i<2; ++i) extra_field64_0[i] = other.extra_field64_0[i];
        extra_field64_1 = other.extra_field64_1 + 64;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType64& operator=(const TestType64& other) {
        if(this != &other) {
            id = other.id + 64;
            for(int i=0; i<64; ++i) unique_data[i] = other.unique_data[i] + 64;
            for(int i=0; i<2; ++i) extra_field64_0[i] = other.extra_field64_0[i];
            extra_field64_1 = other.extra_field64_1 + 64;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType64& other) const { return id < other.id; }
    bool operator==(const TestType64& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 65
struct TestType65 {
    char unique_data[71];
    int id;
    double extra_field65_0;
    char** extra_field65_1;
    double extra_field65_2[4];
    unsigned long long extra_field65_3[5];
    unsigned int extra_field65_4;
    double padding[6];
    TestType65()
        : id(65), extra_field65_0(65 * 1), extra_field65_1(nullptr), extra_field65_4(65 * 5) {
        // Initialize unique_data array
        for(int i=0; i<71; ++i) unique_data[i] = (i+65) % 256;
        for(int i=0; i<4; ++i) extra_field65_2[i] = 65 + i;
        for(int i=0; i<5; ++i) extra_field65_3[i] = 65 + i;
        for(int i=0; i<6; ++i) padding[i] = 65 + i * 0.1;
    }
    TestType65(const TestType65& other) {
        id = other.id + 65;
        for(int i=0; i<71; ++i) unique_data[i] = other.unique_data[i] + 65;
        extra_field65_0 = other.extra_field65_0 + 65;
        extra_field65_1 = other.extra_field65_1;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field65_2[i] = other.extra_field65_2[i];
        for(int i=0; i<5; ++i) extra_field65_3[i] = other.extra_field65_3[i];
        extra_field65_4 = other.extra_field65_4 + 65;
        for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType65& operator=(const TestType65& other) {
        if(this != &other) {
            id = other.id + 65;
            for(int i=0; i<71; ++i) unique_data[i] = other.unique_data[i] + 65;
            extra_field65_0 = other.extra_field65_0 + 65;
            extra_field65_1 = other.extra_field65_1;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field65_2[i] = other.extra_field65_2[i];
            for(int i=0; i<5; ++i) extra_field65_3[i] = other.extra_field65_3[i];
            extra_field65_4 = other.extra_field65_4 + 65;
            for(int i=0; i<6; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType65& other) const { return id < other.id; }
    bool operator==(const TestType65& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 66
struct TestType66 {
    char unique_data[84];
    int id;
    unsigned short extra_field66_0;
    unsigned long long extra_field66_1;
    unsigned char extra_field66_2[2];
    float extra_field66_3[7];
    char* extra_field66_4[4];
    TestType66()
        : id(66), extra_field66_0(66 * 1), extra_field66_1(66 * 2) {
        // Initialize unique_data array
        for(int i=0; i<84; ++i) unique_data[i] = (i+66) % 256;
        for(int i=0; i<2; ++i) extra_field66_2[i] = 66 + i;
        for(int i=0; i<7; ++i) extra_field66_3[i] = 66 + i;
        for(int i=0; i<4; ++i) extra_field66_4[i] = nullptr;
    }
    TestType66(const TestType66& other) {
        id = other.id + 66;
        for(int i=0; i<84; ++i) unique_data[i] = other.unique_data[i] + 66;
        extra_field66_0 = other.extra_field66_0 + 66;
        extra_field66_1 = other.extra_field66_1 + 66;
        for(int i=0; i<2; ++i) extra_field66_2[i] = other.extra_field66_2[i];
        for(int i=0; i<7; ++i) extra_field66_3[i] = other.extra_field66_3[i];
        for(int i=0; i<4; ++i) extra_field66_4[i] = other.extra_field66_4[i];
    }
    TestType66& operator=(const TestType66& other) {
        if(this != &other) {
            id = other.id + 66;
            for(int i=0; i<84; ++i) unique_data[i] = other.unique_data[i] + 66;
            extra_field66_0 = other.extra_field66_0 + 66;
            extra_field66_1 = other.extra_field66_1 + 66;
            for(int i=0; i<2; ++i) extra_field66_2[i] = other.extra_field66_2[i];
            for(int i=0; i<7; ++i) extra_field66_3[i] = other.extra_field66_3[i];
            for(int i=0; i<4; ++i) extra_field66_4[i] = other.extra_field66_4[i];
        }
        return *this;
    }
    bool operator<(const TestType66& other) const { return id < other.id; }
    bool operator==(const TestType66& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 67
struct TestType67 {
    char unique_data[76];
    int id;
    long extra_field67_0[8];
    int* extra_field67_1;
    double padding[3];
    TestType67()
        : id(67), extra_field67_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<76; ++i) unique_data[i] = (i+67) % 256;
        for(int i=0; i<8; ++i) extra_field67_0[i] = 67 + i;
        for(int i=0; i<3; ++i) padding[i] = 67 + i * 0.1;
    }
    TestType67(const TestType67& other) {
        id = other.id + 67;
        for(int i=0; i<76; ++i) unique_data[i] = other.unique_data[i] + 67;
        for(int i=0; i<8; ++i) extra_field67_0[i] = other.extra_field67_0[i];
        extra_field67_1 = other.extra_field67_1;  // Shallow copy pointer
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType67& operator=(const TestType67& other) {
        if(this != &other) {
            id = other.id + 67;
            for(int i=0; i<76; ++i) unique_data[i] = other.unique_data[i] + 67;
            for(int i=0; i<8; ++i) extra_field67_0[i] = other.extra_field67_0[i];
            extra_field67_1 = other.extra_field67_1;  // Shallow copy pointer
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType67& other) const { return id < other.id; }
    bool operator==(const TestType67& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 68
struct TestType68 {
    char unique_data[69];
    int id;
    double* extra_field68_0[1];
    char** extra_field68_1;
    double extra_field68_2;
    unsigned short extra_field68_3;
    TestType68()
        : id(68), extra_field68_1(nullptr), extra_field68_2(68 * 3), extra_field68_3(68 * 4) {
        // Initialize unique_data array
        for(int i=0; i<69; ++i) unique_data[i] = (i+68) % 256;
        for(int i=0; i<1; ++i) extra_field68_0[i] = nullptr;
    }
    TestType68(const TestType68& other) {
        id = other.id + 68;
        for(int i=0; i<69; ++i) unique_data[i] = other.unique_data[i] + 68;
        for(int i=0; i<1; ++i) extra_field68_0[i] = other.extra_field68_0[i];
        extra_field68_1 = other.extra_field68_1;  // Shallow copy pointer
        extra_field68_2 = other.extra_field68_2 + 68;
        extra_field68_3 = other.extra_field68_3 + 68;
    }
    TestType68& operator=(const TestType68& other) {
        if(this != &other) {
            id = other.id + 68;
            for(int i=0; i<69; ++i) unique_data[i] = other.unique_data[i] + 68;
            for(int i=0; i<1; ++i) extra_field68_0[i] = other.extra_field68_0[i];
            extra_field68_1 = other.extra_field68_1;  // Shallow copy pointer
            extra_field68_2 = other.extra_field68_2 + 68;
            extra_field68_3 = other.extra_field68_3 + 68;
        }
        return *this;
    }
    bool operator<(const TestType68& other) const { return id < other.id; }
    bool operator==(const TestType68& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 69
struct TestType69 {
    char unique_data[72];
    int id;
    unsigned long long extra_field69_0;
    long long extra_field69_1;
    float* extra_field69_2;
    char extra_field69_3[9];
    char random_padding[7];
    TestType69()
        : id(69), extra_field69_0(69 * 1), extra_field69_1(69 * 2), extra_field69_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<72; ++i) unique_data[i] = (i+69) % 256;
        for(int i=0; i<9; ++i) extra_field69_3[i] = 69 + i;
        for(int i=0; i<7; ++i) random_padding[i] = (69 + i) % 128;
    }
    TestType69(const TestType69& other) {
        id = other.id + 69;
        for(int i=0; i<72; ++i) unique_data[i] = other.unique_data[i] + 69;
        extra_field69_0 = other.extra_field69_0 + 69;
        extra_field69_1 = other.extra_field69_1 + 69;
        extra_field69_2 = other.extra_field69_2;  // Shallow copy pointer
        for(int i=0; i<9; ++i) extra_field69_3[i] = other.extra_field69_3[i];
        for(int i=0; i<7; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType69& operator=(const TestType69& other) {
        if(this != &other) {
            id = other.id + 69;
            for(int i=0; i<72; ++i) unique_data[i] = other.unique_data[i] + 69;
            extra_field69_0 = other.extra_field69_0 + 69;
            extra_field69_1 = other.extra_field69_1 + 69;
            extra_field69_2 = other.extra_field69_2;  // Shallow copy pointer
            for(int i=0; i<9; ++i) extra_field69_3[i] = other.extra_field69_3[i];
            for(int i=0; i<7; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType69& other) const { return id < other.id; }
    bool operator==(const TestType69& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 70
struct TestType70 {
    char unique_data[76];
    int id;
    double extra_field70_0;
    int* extra_field70_1[3];
    double padding[8];
    TestType70()
        : id(70), extra_field70_0(70 * 1) {
        // Initialize unique_data array
        for(int i=0; i<76; ++i) unique_data[i] = (i+70) % 256;
        for(int i=0; i<3; ++i) extra_field70_1[i] = nullptr;
        for(int i=0; i<8; ++i) padding[i] = 70 + i * 0.1;
    }
    TestType70(const TestType70& other) {
        id = other.id + 70;
        for(int i=0; i<76; ++i) unique_data[i] = other.unique_data[i] + 70;
        extra_field70_0 = other.extra_field70_0 + 70;
        for(int i=0; i<3; ++i) extra_field70_1[i] = other.extra_field70_1[i];
        for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType70& operator=(const TestType70& other) {
        if(this != &other) {
            id = other.id + 70;
            for(int i=0; i<76; ++i) unique_data[i] = other.unique_data[i] + 70;
            extra_field70_0 = other.extra_field70_0 + 70;
            for(int i=0; i<3; ++i) extra_field70_1[i] = other.extra_field70_1[i];
            for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType70& other) const { return id < other.id; }
    bool operator==(const TestType70& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 71
struct TestType71 {
    char unique_data[90];
    int id;
    unsigned char extra_field71_0[4];
    long extra_field71_1[10];
    long extra_field71_2[3];
    double padding[2];
    TestType71()
        : id(71) {
        // Initialize unique_data array
        for(int i=0; i<90; ++i) unique_data[i] = (i+71) % 256;
        for(int i=0; i<4; ++i) extra_field71_0[i] = 71 + i;
        for(int i=0; i<10; ++i) extra_field71_1[i] = 71 + i;
        for(int i=0; i<3; ++i) extra_field71_2[i] = 71 + i;
        for(int i=0; i<2; ++i) padding[i] = 71 + i * 0.1;
    }
    TestType71(const TestType71& other) {
        id = other.id + 71;
        for(int i=0; i<90; ++i) unique_data[i] = other.unique_data[i] + 71;
        for(int i=0; i<4; ++i) extra_field71_0[i] = other.extra_field71_0[i];
        for(int i=0; i<10; ++i) extra_field71_1[i] = other.extra_field71_1[i];
        for(int i=0; i<3; ++i) extra_field71_2[i] = other.extra_field71_2[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType71& operator=(const TestType71& other) {
        if(this != &other) {
            id = other.id + 71;
            for(int i=0; i<90; ++i) unique_data[i] = other.unique_data[i] + 71;
            for(int i=0; i<4; ++i) extra_field71_0[i] = other.extra_field71_0[i];
            for(int i=0; i<10; ++i) extra_field71_1[i] = other.extra_field71_1[i];
            for(int i=0; i<3; ++i) extra_field71_2[i] = other.extra_field71_2[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType71& other) const { return id < other.id; }
    bool operator==(const TestType71& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 72
struct TestType72 {
    char unique_data[74];
    int id;
    unsigned long long extra_field72_0;
    float extra_field72_1;
    float* extra_field72_2;
    unsigned int extra_field72_3;
    long extra_field72_4;
    TestType72()
        : id(72), extra_field72_0(72 * 1), extra_field72_1(72 * 2), extra_field72_2(nullptr), extra_field72_3(72 * 4), extra_field72_4(72 * 5) {
        // Initialize unique_data array
        for(int i=0; i<74; ++i) unique_data[i] = (i+72) % 256;
    }
    TestType72(const TestType72& other) {
        id = other.id + 72;
        for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 72;
        extra_field72_0 = other.extra_field72_0 + 72;
        extra_field72_1 = other.extra_field72_1 + 72;
        extra_field72_2 = other.extra_field72_2;  // Shallow copy pointer
        extra_field72_3 = other.extra_field72_3 + 72;
        extra_field72_4 = other.extra_field72_4 + 72;
    }
    TestType72& operator=(const TestType72& other) {
        if(this != &other) {
            id = other.id + 72;
            for(int i=0; i<74; ++i) unique_data[i] = other.unique_data[i] + 72;
            extra_field72_0 = other.extra_field72_0 + 72;
            extra_field72_1 = other.extra_field72_1 + 72;
            extra_field72_2 = other.extra_field72_2;  // Shallow copy pointer
            extra_field72_3 = other.extra_field72_3 + 72;
            extra_field72_4 = other.extra_field72_4 + 72;
        }
        return *this;
    }
    bool operator<(const TestType72& other) const { return id < other.id; }
    bool operator==(const TestType72& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 73
struct TestType73 {
    char unique_data[91];
    int id;
    unsigned long long extra_field73_0;
    long long extra_field73_1;
    void* extra_field73_2;
    char random_padding[1];
    TestType73()
        : id(73), extra_field73_0(73 * 1), extra_field73_1(73 * 2), extra_field73_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<91; ++i) unique_data[i] = (i+73) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (73 + i) % 128;
    }
    TestType73(const TestType73& other) {
        id = other.id + 73;
        for(int i=0; i<91; ++i) unique_data[i] = other.unique_data[i] + 73;
        extra_field73_0 = other.extra_field73_0 + 73;
        extra_field73_1 = other.extra_field73_1 + 73;
        extra_field73_2 = other.extra_field73_2;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType73& operator=(const TestType73& other) {
        if(this != &other) {
            id = other.id + 73;
            for(int i=0; i<91; ++i) unique_data[i] = other.unique_data[i] + 73;
            extra_field73_0 = other.extra_field73_0 + 73;
            extra_field73_1 = other.extra_field73_1 + 73;
            extra_field73_2 = other.extra_field73_2;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType73& other) const { return id < other.id; }
    bool operator==(const TestType73& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 74
struct TestType74 {
    char unique_data[77];
    int id;
    char** extra_field74_0;
    double padding[2];
    TestType74()
        : id(74), extra_field74_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<77; ++i) unique_data[i] = (i+74) % 256;
        for(int i=0; i<2; ++i) padding[i] = 74 + i * 0.1;
    }
    TestType74(const TestType74& other) {
        id = other.id + 74;
        for(int i=0; i<77; ++i) unique_data[i] = other.unique_data[i] + 74;
        extra_field74_0 = other.extra_field74_0;  // Shallow copy pointer
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType74& operator=(const TestType74& other) {
        if(this != &other) {
            id = other.id + 74;
            for(int i=0; i<77; ++i) unique_data[i] = other.unique_data[i] + 74;
            extra_field74_0 = other.extra_field74_0;  // Shallow copy pointer
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType74& other) const { return id < other.id; }
    bool operator==(const TestType74& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 75
struct TestType75 {
    char unique_data[81];
    int id;
    unsigned char extra_field75_0;
    char extra_field75_1;
    unsigned int extra_field75_2[7];
    float* extra_field75_3;
    char* extra_field75_4[3];
    double padding[5];
    TestType75()
        : id(75), extra_field75_0(75 * 1), extra_field75_1(75 * 2), extra_field75_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<81; ++i) unique_data[i] = (i+75) % 256;
        for(int i=0; i<7; ++i) extra_field75_2[i] = 75 + i;
        for(int i=0; i<3; ++i) extra_field75_4[i] = nullptr;
        for(int i=0; i<5; ++i) padding[i] = 75 + i * 0.1;
    }
    TestType75(const TestType75& other) {
        id = other.id + 75;
        for(int i=0; i<81; ++i) unique_data[i] = other.unique_data[i] + 75;
        extra_field75_0 = other.extra_field75_0 + 75;
        extra_field75_1 = other.extra_field75_1 + 75;
        for(int i=0; i<7; ++i) extra_field75_2[i] = other.extra_field75_2[i];
        extra_field75_3 = other.extra_field75_3;  // Shallow copy pointer
        for(int i=0; i<3; ++i) extra_field75_4[i] = other.extra_field75_4[i];
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType75& operator=(const TestType75& other) {
        if(this != &other) {
            id = other.id + 75;
            for(int i=0; i<81; ++i) unique_data[i] = other.unique_data[i] + 75;
            extra_field75_0 = other.extra_field75_0 + 75;
            extra_field75_1 = other.extra_field75_1 + 75;
            for(int i=0; i<7; ++i) extra_field75_2[i] = other.extra_field75_2[i];
            extra_field75_3 = other.extra_field75_3;  // Shallow copy pointer
            for(int i=0; i<3; ++i) extra_field75_4[i] = other.extra_field75_4[i];
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType75& other) const { return id < other.id; }
    bool operator==(const TestType75& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 76
struct TestType76 {
    char unique_data[89];
    int id;
    unsigned long extra_field76_0[4];
    long* extra_field76_1[2];
    TestType76()
        : id(76) {
        // Initialize unique_data array
        for(int i=0; i<89; ++i) unique_data[i] = (i+76) % 256;
        for(int i=0; i<4; ++i) extra_field76_0[i] = 76 + i;
        for(int i=0; i<2; ++i) extra_field76_1[i] = nullptr;
    }
    TestType76(const TestType76& other) {
        id = other.id + 76;
        for(int i=0; i<89; ++i) unique_data[i] = other.unique_data[i] + 76;
        for(int i=0; i<4; ++i) extra_field76_0[i] = other.extra_field76_0[i];
        for(int i=0; i<2; ++i) extra_field76_1[i] = other.extra_field76_1[i];
    }
    TestType76& operator=(const TestType76& other) {
        if(this != &other) {
            id = other.id + 76;
            for(int i=0; i<89; ++i) unique_data[i] = other.unique_data[i] + 76;
            for(int i=0; i<4; ++i) extra_field76_0[i] = other.extra_field76_0[i];
            for(int i=0; i<2; ++i) extra_field76_1[i] = other.extra_field76_1[i];
        }
        return *this;
    }
    bool operator<(const TestType76& other) const { return id < other.id; }
    bool operator==(const TestType76& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 77
struct TestType77 {
    char unique_data[81];
    int id;
    short extra_field77_0[3];
    short extra_field77_1;
    short extra_field77_2;
    char extra_field77_3[9];
    char** extra_field77_4[1];
    char random_padding[5];
    TestType77()
        : id(77), extra_field77_1(77 * 2), extra_field77_2(77 * 3) {
        // Initialize unique_data array
        for(int i=0; i<81; ++i) unique_data[i] = (i+77) % 256;
        for(int i=0; i<3; ++i) extra_field77_0[i] = 77 + i;
        for(int i=0; i<9; ++i) extra_field77_3[i] = 77 + i;
        for(int i=0; i<1; ++i) extra_field77_4[i] = nullptr;
        for(int i=0; i<5; ++i) random_padding[i] = (77 + i) % 128;
    }
    TestType77(const TestType77& other) {
        id = other.id + 77;
        for(int i=0; i<81; ++i) unique_data[i] = other.unique_data[i] + 77;
        for(int i=0; i<3; ++i) extra_field77_0[i] = other.extra_field77_0[i];
        extra_field77_1 = other.extra_field77_1 + 77;
        extra_field77_2 = other.extra_field77_2 + 77;
        for(int i=0; i<9; ++i) extra_field77_3[i] = other.extra_field77_3[i];
        for(int i=0; i<1; ++i) extra_field77_4[i] = other.extra_field77_4[i];
        for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType77& operator=(const TestType77& other) {
        if(this != &other) {
            id = other.id + 77;
            for(int i=0; i<81; ++i) unique_data[i] = other.unique_data[i] + 77;
            for(int i=0; i<3; ++i) extra_field77_0[i] = other.extra_field77_0[i];
            extra_field77_1 = other.extra_field77_1 + 77;
            extra_field77_2 = other.extra_field77_2 + 77;
            for(int i=0; i<9; ++i) extra_field77_3[i] = other.extra_field77_3[i];
            for(int i=0; i<1; ++i) extra_field77_4[i] = other.extra_field77_4[i];
            for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType77& other) const { return id < other.id; }
    bool operator==(const TestType77& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 78
struct TestType78 {
    char unique_data[85];
    int id;
    char** extra_field78_0;
    long double extra_field78_1;
    char random_padding[5];
    TestType78()
        : id(78), extra_field78_0(nullptr), extra_field78_1(78 * 2) {
        // Initialize unique_data array
        for(int i=0; i<85; ++i) unique_data[i] = (i+78) % 256;
        for(int i=0; i<5; ++i) random_padding[i] = (78 + i) % 128;
    }
    TestType78(const TestType78& other) {
        id = other.id + 78;
        for(int i=0; i<85; ++i) unique_data[i] = other.unique_data[i] + 78;
        extra_field78_0 = other.extra_field78_0;  // Shallow copy pointer
        extra_field78_1 = other.extra_field78_1 + 78;
        for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType78& operator=(const TestType78& other) {
        if(this != &other) {
            id = other.id + 78;
            for(int i=0; i<85; ++i) unique_data[i] = other.unique_data[i] + 78;
            extra_field78_0 = other.extra_field78_0;  // Shallow copy pointer
            extra_field78_1 = other.extra_field78_1 + 78;
            for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType78& other) const { return id < other.id; }
    bool operator==(const TestType78& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 79
struct TestType79 {
    char unique_data[88];
    int id;
    short extra_field79_0;
    float extra_field79_1;
    char random_padding[3];
    TestType79()
        : id(79), extra_field79_0(79 * 1), extra_field79_1(79 * 2) {
        // Initialize unique_data array
        for(int i=0; i<88; ++i) unique_data[i] = (i+79) % 256;
        for(int i=0; i<3; ++i) random_padding[i] = (79 + i) % 128;
    }
    TestType79(const TestType79& other) {
        id = other.id + 79;
        for(int i=0; i<88; ++i) unique_data[i] = other.unique_data[i] + 79;
        extra_field79_0 = other.extra_field79_0 + 79;
        extra_field79_1 = other.extra_field79_1 + 79;
        for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType79& operator=(const TestType79& other) {
        if(this != &other) {
            id = other.id + 79;
            for(int i=0; i<88; ++i) unique_data[i] = other.unique_data[i] + 79;
            extra_field79_0 = other.extra_field79_0 + 79;
            extra_field79_1 = other.extra_field79_1 + 79;
            for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType79& other) const { return id < other.id; }
    bool operator==(const TestType79& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 80
struct TestType80 {
    char unique_data[97];
    int id;
    double extra_field80_0;
    unsigned int extra_field80_1[6];
    long* extra_field80_2[1];
    unsigned char extra_field80_3;
    float* extra_field80_4;
    char random_padding[1];
    TestType80()
        : id(80), extra_field80_0(80 * 1), extra_field80_3(80 * 4), extra_field80_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<97; ++i) unique_data[i] = (i+80) % 256;
        for(int i=0; i<6; ++i) extra_field80_1[i] = 80 + i;
        for(int i=0; i<1; ++i) extra_field80_2[i] = nullptr;
        for(int i=0; i<1; ++i) random_padding[i] = (80 + i) % 128;
    }
    TestType80(const TestType80& other) {
        id = other.id + 80;
        for(int i=0; i<97; ++i) unique_data[i] = other.unique_data[i] + 80;
        extra_field80_0 = other.extra_field80_0 + 80;
        for(int i=0; i<6; ++i) extra_field80_1[i] = other.extra_field80_1[i];
        for(int i=0; i<1; ++i) extra_field80_2[i] = other.extra_field80_2[i];
        extra_field80_3 = other.extra_field80_3 + 80;
        extra_field80_4 = other.extra_field80_4;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType80& operator=(const TestType80& other) {
        if(this != &other) {
            id = other.id + 80;
            for(int i=0; i<97; ++i) unique_data[i] = other.unique_data[i] + 80;
            extra_field80_0 = other.extra_field80_0 + 80;
            for(int i=0; i<6; ++i) extra_field80_1[i] = other.extra_field80_1[i];
            for(int i=0; i<1; ++i) extra_field80_2[i] = other.extra_field80_2[i];
            extra_field80_3 = other.extra_field80_3 + 80;
            extra_field80_4 = other.extra_field80_4;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType80& other) const { return id < other.id; }
    bool operator==(const TestType80& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 81
struct TestType81 {
    char unique_data[88];
    int id;
    long* extra_field81_0;
    long* extra_field81_1[5];
    double* extra_field81_2[5];
    char** extra_field81_3[3];
    float extra_field81_4[3];
    char random_padding[2];
    TestType81()
        : id(81), extra_field81_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<88; ++i) unique_data[i] = (i+81) % 256;
        for(int i=0; i<5; ++i) extra_field81_1[i] = nullptr;
        for(int i=0; i<5; ++i) extra_field81_2[i] = nullptr;
        for(int i=0; i<3; ++i) extra_field81_3[i] = nullptr;
        for(int i=0; i<3; ++i) extra_field81_4[i] = 81 + i;
        for(int i=0; i<2; ++i) random_padding[i] = (81 + i) % 128;
    }
    TestType81(const TestType81& other) {
        id = other.id + 81;
        for(int i=0; i<88; ++i) unique_data[i] = other.unique_data[i] + 81;
        extra_field81_0 = other.extra_field81_0;  // Shallow copy pointer
        for(int i=0; i<5; ++i) extra_field81_1[i] = other.extra_field81_1[i];
        for(int i=0; i<5; ++i) extra_field81_2[i] = other.extra_field81_2[i];
        for(int i=0; i<3; ++i) extra_field81_3[i] = other.extra_field81_3[i];
        for(int i=0; i<3; ++i) extra_field81_4[i] = other.extra_field81_4[i];
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType81& operator=(const TestType81& other) {
        if(this != &other) {
            id = other.id + 81;
            for(int i=0; i<88; ++i) unique_data[i] = other.unique_data[i] + 81;
            extra_field81_0 = other.extra_field81_0;  // Shallow copy pointer
            for(int i=0; i<5; ++i) extra_field81_1[i] = other.extra_field81_1[i];
            for(int i=0; i<5; ++i) extra_field81_2[i] = other.extra_field81_2[i];
            for(int i=0; i<3; ++i) extra_field81_3[i] = other.extra_field81_3[i];
            for(int i=0; i<3; ++i) extra_field81_4[i] = other.extra_field81_4[i];
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType81& other) const { return id < other.id; }
    bool operator==(const TestType81& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 82
struct TestType82 {
    char unique_data[83];
    int id;
    float extra_field82_0;
    TestType82()
        : id(82), extra_field82_0(82 * 1) {
        // Initialize unique_data array
        for(int i=0; i<83; ++i) unique_data[i] = (i+82) % 256;
    }
    TestType82(const TestType82& other) {
        id = other.id + 82;
        for(int i=0; i<83; ++i) unique_data[i] = other.unique_data[i] + 82;
        extra_field82_0 = other.extra_field82_0 + 82;
    }
    TestType82& operator=(const TestType82& other) {
        if(this != &other) {
            id = other.id + 82;
            for(int i=0; i<83; ++i) unique_data[i] = other.unique_data[i] + 82;
            extra_field82_0 = other.extra_field82_0 + 82;
        }
        return *this;
    }
    bool operator<(const TestType82& other) const { return id < other.id; }
    bool operator==(const TestType82& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 83
struct TestType83 {
    char unique_data[84];
    int id;
    unsigned short extra_field83_0;
    unsigned long long extra_field83_1;
    char random_padding[1];
    TestType83()
        : id(83), extra_field83_0(83 * 1), extra_field83_1(83 * 2) {
        // Initialize unique_data array
        for(int i=0; i<84; ++i) unique_data[i] = (i+83) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (83 + i) % 128;
    }
    TestType83(const TestType83& other) {
        id = other.id + 83;
        for(int i=0; i<84; ++i) unique_data[i] = other.unique_data[i] + 83;
        extra_field83_0 = other.extra_field83_0 + 83;
        extra_field83_1 = other.extra_field83_1 + 83;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType83& operator=(const TestType83& other) {
        if(this != &other) {
            id = other.id + 83;
            for(int i=0; i<84; ++i) unique_data[i] = other.unique_data[i] + 83;
            extra_field83_0 = other.extra_field83_0 + 83;
            extra_field83_1 = other.extra_field83_1 + 83;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType83& other) const { return id < other.id; }
    bool operator==(const TestType83& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 84
struct TestType84 {
    char unique_data[93];
    int id;
    int** extra_field84_0;
    long double extra_field84_1;
    long long extra_field84_2[5];
    unsigned long extra_field84_3;
    char* extra_field84_4[4];
    double padding[1];
    TestType84()
        : id(84), extra_field84_0(nullptr), extra_field84_1(84 * 2), extra_field84_3(84 * 4) {
        // Initialize unique_data array
        for(int i=0; i<93; ++i) unique_data[i] = (i+84) % 256;
        for(int i=0; i<5; ++i) extra_field84_2[i] = 84 + i;
        for(int i=0; i<4; ++i) extra_field84_4[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 84 + i * 0.1;
    }
    TestType84(const TestType84& other) {
        id = other.id + 84;
        for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 84;
        extra_field84_0 = other.extra_field84_0;  // Shallow copy pointer
        extra_field84_1 = other.extra_field84_1 + 84;
        for(int i=0; i<5; ++i) extra_field84_2[i] = other.extra_field84_2[i];
        extra_field84_3 = other.extra_field84_3 + 84;
        for(int i=0; i<4; ++i) extra_field84_4[i] = other.extra_field84_4[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType84& operator=(const TestType84& other) {
        if(this != &other) {
            id = other.id + 84;
            for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 84;
            extra_field84_0 = other.extra_field84_0;  // Shallow copy pointer
            extra_field84_1 = other.extra_field84_1 + 84;
            for(int i=0; i<5; ++i) extra_field84_2[i] = other.extra_field84_2[i];
            extra_field84_3 = other.extra_field84_3 + 84;
            for(int i=0; i<4; ++i) extra_field84_4[i] = other.extra_field84_4[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType84& other) const { return id < other.id; }
    bool operator==(const TestType84& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 85
struct TestType85 {
    char unique_data[96];
    int id;
    int** extra_field85_0;
    char extra_field85_1;
    int** extra_field85_2;
    unsigned long extra_field85_3;
    int** extra_field85_4;
    double padding[1];
    TestType85()
        : id(85), extra_field85_0(nullptr), extra_field85_1(85 * 2), extra_field85_2(nullptr), extra_field85_3(85 * 4), extra_field85_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<96; ++i) unique_data[i] = (i+85) % 256;
        for(int i=0; i<1; ++i) padding[i] = 85 + i * 0.1;
    }
    TestType85(const TestType85& other) {
        id = other.id + 85;
        for(int i=0; i<96; ++i) unique_data[i] = other.unique_data[i] + 85;
        extra_field85_0 = other.extra_field85_0;  // Shallow copy pointer
        extra_field85_1 = other.extra_field85_1 + 85;
        extra_field85_2 = other.extra_field85_2;  // Shallow copy pointer
        extra_field85_3 = other.extra_field85_3 + 85;
        extra_field85_4 = other.extra_field85_4;  // Shallow copy pointer
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType85& operator=(const TestType85& other) {
        if(this != &other) {
            id = other.id + 85;
            for(int i=0; i<96; ++i) unique_data[i] = other.unique_data[i] + 85;
            extra_field85_0 = other.extra_field85_0;  // Shallow copy pointer
            extra_field85_1 = other.extra_field85_1 + 85;
            extra_field85_2 = other.extra_field85_2;  // Shallow copy pointer
            extra_field85_3 = other.extra_field85_3 + 85;
            extra_field85_4 = other.extra_field85_4;  // Shallow copy pointer
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType85& other) const { return id < other.id; }
    bool operator==(const TestType85& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 86
struct TestType86 {
    char unique_data[97];
    int id;
    float* extra_field86_0[1];
    char* extra_field86_1[5];
    TestType86()
        : id(86) {
        // Initialize unique_data array
        for(int i=0; i<97; ++i) unique_data[i] = (i+86) % 256;
        for(int i=0; i<1; ++i) extra_field86_0[i] = nullptr;
        for(int i=0; i<5; ++i) extra_field86_1[i] = nullptr;
    }
    TestType86(const TestType86& other) {
        id = other.id + 86;
        for(int i=0; i<97; ++i) unique_data[i] = other.unique_data[i] + 86;
        for(int i=0; i<1; ++i) extra_field86_0[i] = other.extra_field86_0[i];
        for(int i=0; i<5; ++i) extra_field86_1[i] = other.extra_field86_1[i];
    }
    TestType86& operator=(const TestType86& other) {
        if(this != &other) {
            id = other.id + 86;
            for(int i=0; i<97; ++i) unique_data[i] = other.unique_data[i] + 86;
            for(int i=0; i<1; ++i) extra_field86_0[i] = other.extra_field86_0[i];
            for(int i=0; i<5; ++i) extra_field86_1[i] = other.extra_field86_1[i];
        }
        return *this;
    }
    bool operator<(const TestType86& other) const { return id < other.id; }
    bool operator==(const TestType86& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 87
struct TestType87 {
    char unique_data[100];
    int id;
    int extra_field87_0;
    char extra_field87_1[2];
    char** extra_field87_2;
    double padding[3];
    TestType87()
        : id(87), extra_field87_0(87 * 1), extra_field87_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<100; ++i) unique_data[i] = (i+87) % 256;
        for(int i=0; i<2; ++i) extra_field87_1[i] = 87 + i;
        for(int i=0; i<3; ++i) padding[i] = 87 + i * 0.1;
    }
    TestType87(const TestType87& other) {
        id = other.id + 87;
        for(int i=0; i<100; ++i) unique_data[i] = other.unique_data[i] + 87;
        extra_field87_0 = other.extra_field87_0 + 87;
        for(int i=0; i<2; ++i) extra_field87_1[i] = other.extra_field87_1[i];
        extra_field87_2 = other.extra_field87_2;  // Shallow copy pointer
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType87& operator=(const TestType87& other) {
        if(this != &other) {
            id = other.id + 87;
            for(int i=0; i<100; ++i) unique_data[i] = other.unique_data[i] + 87;
            extra_field87_0 = other.extra_field87_0 + 87;
            for(int i=0; i<2; ++i) extra_field87_1[i] = other.extra_field87_1[i];
            extra_field87_2 = other.extra_field87_2;  // Shallow copy pointer
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType87& other) const { return id < other.id; }
    bool operator==(const TestType87& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 88
struct TestType88 {
    char unique_data[89];
    int id;
    void* extra_field88_0;
    float* extra_field88_1;
    char* extra_field88_2;
    unsigned long long extra_field88_3[4];
    long* extra_field88_4[2];
    char random_padding[2];
    TestType88()
        : id(88), extra_field88_0(nullptr), extra_field88_1(nullptr), extra_field88_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<89; ++i) unique_data[i] = (i+88) % 256;
        for(int i=0; i<4; ++i) extra_field88_3[i] = 88 + i;
        for(int i=0; i<2; ++i) extra_field88_4[i] = nullptr;
        for(int i=0; i<2; ++i) random_padding[i] = (88 + i) % 128;
    }
    TestType88(const TestType88& other) {
        id = other.id + 88;
        for(int i=0; i<89; ++i) unique_data[i] = other.unique_data[i] + 88;
        extra_field88_0 = other.extra_field88_0;  // Shallow copy pointer
        extra_field88_1 = other.extra_field88_1;  // Shallow copy pointer
        extra_field88_2 = other.extra_field88_2;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field88_3[i] = other.extra_field88_3[i];
        for(int i=0; i<2; ++i) extra_field88_4[i] = other.extra_field88_4[i];
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType88& operator=(const TestType88& other) {
        if(this != &other) {
            id = other.id + 88;
            for(int i=0; i<89; ++i) unique_data[i] = other.unique_data[i] + 88;
            extra_field88_0 = other.extra_field88_0;  // Shallow copy pointer
            extra_field88_1 = other.extra_field88_1;  // Shallow copy pointer
            extra_field88_2 = other.extra_field88_2;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field88_3[i] = other.extra_field88_3[i];
            for(int i=0; i<2; ++i) extra_field88_4[i] = other.extra_field88_4[i];
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType88& other) const { return id < other.id; }
    bool operator==(const TestType88& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 89
struct TestType89 {
    char unique_data[93];
    int id;
    unsigned char extra_field89_0[10];
    float* extra_field89_1[3];
    long* extra_field89_2;
    double* extra_field89_3;
    TestType89()
        : id(89), extra_field89_2(nullptr), extra_field89_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<93; ++i) unique_data[i] = (i+89) % 256;
        for(int i=0; i<10; ++i) extra_field89_0[i] = 89 + i;
        for(int i=0; i<3; ++i) extra_field89_1[i] = nullptr;
    }
    TestType89(const TestType89& other) {
        id = other.id + 89;
        for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 89;
        for(int i=0; i<10; ++i) extra_field89_0[i] = other.extra_field89_0[i];
        for(int i=0; i<3; ++i) extra_field89_1[i] = other.extra_field89_1[i];
        extra_field89_2 = other.extra_field89_2;  // Shallow copy pointer
        extra_field89_3 = other.extra_field89_3;  // Shallow copy pointer
    }
    TestType89& operator=(const TestType89& other) {
        if(this != &other) {
            id = other.id + 89;
            for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 89;
            for(int i=0; i<10; ++i) extra_field89_0[i] = other.extra_field89_0[i];
            for(int i=0; i<3; ++i) extra_field89_1[i] = other.extra_field89_1[i];
            extra_field89_2 = other.extra_field89_2;  // Shallow copy pointer
            extra_field89_3 = other.extra_field89_3;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType89& other) const { return id < other.id; }
    bool operator==(const TestType89& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 90
struct TestType90 {
    char unique_data[101];
    int id;
    unsigned long long extra_field90_0[8];
    TestType90()
        : id(90) {
        // Initialize unique_data array
        for(int i=0; i<101; ++i) unique_data[i] = (i+90) % 256;
        for(int i=0; i<8; ++i) extra_field90_0[i] = 90 + i;
    }
    TestType90(const TestType90& other) {
        id = other.id + 90;
        for(int i=0; i<101; ++i) unique_data[i] = other.unique_data[i] + 90;
        for(int i=0; i<8; ++i) extra_field90_0[i] = other.extra_field90_0[i];
    }
    TestType90& operator=(const TestType90& other) {
        if(this != &other) {
            id = other.id + 90;
            for(int i=0; i<101; ++i) unique_data[i] = other.unique_data[i] + 90;
            for(int i=0; i<8; ++i) extra_field90_0[i] = other.extra_field90_0[i];
        }
        return *this;
    }
    bool operator<(const TestType90& other) const { return id < other.id; }
    bool operator==(const TestType90& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 91
struct TestType91 {
    char unique_data[109];
    int id;
    double* extra_field91_0;
    long extra_field91_1;
    unsigned short extra_field91_2;
    double extra_field91_3;
    char random_padding[1];
    TestType91()
        : id(91), extra_field91_0(nullptr), extra_field91_1(91 * 2), extra_field91_2(91 * 3), extra_field91_3(91 * 4) {
        // Initialize unique_data array
        for(int i=0; i<109; ++i) unique_data[i] = (i+91) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (91 + i) % 128;
    }
    TestType91(const TestType91& other) {
        id = other.id + 91;
        for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 91;
        extra_field91_0 = other.extra_field91_0;  // Shallow copy pointer
        extra_field91_1 = other.extra_field91_1 + 91;
        extra_field91_2 = other.extra_field91_2 + 91;
        extra_field91_3 = other.extra_field91_3 + 91;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType91& operator=(const TestType91& other) {
        if(this != &other) {
            id = other.id + 91;
            for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 91;
            extra_field91_0 = other.extra_field91_0;  // Shallow copy pointer
            extra_field91_1 = other.extra_field91_1 + 91;
            extra_field91_2 = other.extra_field91_2 + 91;
            extra_field91_3 = other.extra_field91_3 + 91;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType91& other) const { return id < other.id; }
    bool operator==(const TestType91& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 92
struct TestType92 {
    char unique_data[93];
    int id;
    long long extra_field92_0;
    int extra_field92_1;
    TestType92()
        : id(92), extra_field92_0(92 * 1), extra_field92_1(92 * 2) {
        // Initialize unique_data array
        for(int i=0; i<93; ++i) unique_data[i] = (i+92) % 256;
    }
    TestType92(const TestType92& other) {
        id = other.id + 92;
        for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 92;
        extra_field92_0 = other.extra_field92_0 + 92;
        extra_field92_1 = other.extra_field92_1 + 92;
    }
    TestType92& operator=(const TestType92& other) {
        if(this != &other) {
            id = other.id + 92;
            for(int i=0; i<93; ++i) unique_data[i] = other.unique_data[i] + 92;
            extra_field92_0 = other.extra_field92_0 + 92;
            extra_field92_1 = other.extra_field92_1 + 92;
        }
        return *this;
    }
    bool operator<(const TestType92& other) const { return id < other.id; }
    bool operator==(const TestType92& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 93
struct TestType93 {
    char unique_data[109];
    int id;
    unsigned long long extra_field93_0;
    long extra_field93_1;
    long* extra_field93_2[1];
    unsigned int extra_field93_3[6];
    unsigned char extra_field93_4;
    double padding[7];
    TestType93()
        : id(93), extra_field93_0(93 * 1), extra_field93_1(93 * 2), extra_field93_4(93 * 5) {
        // Initialize unique_data array
        for(int i=0; i<109; ++i) unique_data[i] = (i+93) % 256;
        for(int i=0; i<1; ++i) extra_field93_2[i] = nullptr;
        for(int i=0; i<6; ++i) extra_field93_3[i] = 93 + i;
        for(int i=0; i<7; ++i) padding[i] = 93 + i * 0.1;
    }
    TestType93(const TestType93& other) {
        id = other.id + 93;
        for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 93;
        extra_field93_0 = other.extra_field93_0 + 93;
        extra_field93_1 = other.extra_field93_1 + 93;
        for(int i=0; i<1; ++i) extra_field93_2[i] = other.extra_field93_2[i];
        for(int i=0; i<6; ++i) extra_field93_3[i] = other.extra_field93_3[i];
        extra_field93_4 = other.extra_field93_4 + 93;
        for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType93& operator=(const TestType93& other) {
        if(this != &other) {
            id = other.id + 93;
            for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 93;
            extra_field93_0 = other.extra_field93_0 + 93;
            extra_field93_1 = other.extra_field93_1 + 93;
            for(int i=0; i<1; ++i) extra_field93_2[i] = other.extra_field93_2[i];
            for(int i=0; i<6; ++i) extra_field93_3[i] = other.extra_field93_3[i];
            extra_field93_4 = other.extra_field93_4 + 93;
            for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType93& other) const { return id < other.id; }
    bool operator==(const TestType93& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 94
struct TestType94 {
    char unique_data[109];
    int id;
    long extra_field94_0;
    unsigned long long extra_field94_1;
    char** extra_field94_2;
    double padding[8];
    TestType94()
        : id(94), extra_field94_0(94 * 1), extra_field94_1(94 * 2), extra_field94_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<109; ++i) unique_data[i] = (i+94) % 256;
        for(int i=0; i<8; ++i) padding[i] = 94 + i * 0.1;
    }
    TestType94(const TestType94& other) {
        id = other.id + 94;
        for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 94;
        extra_field94_0 = other.extra_field94_0 + 94;
        extra_field94_1 = other.extra_field94_1 + 94;
        extra_field94_2 = other.extra_field94_2;  // Shallow copy pointer
        for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType94& operator=(const TestType94& other) {
        if(this != &other) {
            id = other.id + 94;
            for(int i=0; i<109; ++i) unique_data[i] = other.unique_data[i] + 94;
            extra_field94_0 = other.extra_field94_0 + 94;
            extra_field94_1 = other.extra_field94_1 + 94;
            extra_field94_2 = other.extra_field94_2;  // Shallow copy pointer
            for(int i=0; i<8; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType94& other) const { return id < other.id; }
    bool operator==(const TestType94& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 95
struct TestType95 {
    char unique_data[106];
    int id;
    unsigned int extra_field95_0;
    float extra_field95_1[4];
    double padding[1];
    TestType95()
        : id(95), extra_field95_0(95 * 1) {
        // Initialize unique_data array
        for(int i=0; i<106; ++i) unique_data[i] = (i+95) % 256;
        for(int i=0; i<4; ++i) extra_field95_1[i] = 95 + i;
        for(int i=0; i<1; ++i) padding[i] = 95 + i * 0.1;
    }
    TestType95(const TestType95& other) {
        id = other.id + 95;
        for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 95;
        extra_field95_0 = other.extra_field95_0 + 95;
        for(int i=0; i<4; ++i) extra_field95_1[i] = other.extra_field95_1[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType95& operator=(const TestType95& other) {
        if(this != &other) {
            id = other.id + 95;
            for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 95;
            extra_field95_0 = other.extra_field95_0 + 95;
            for(int i=0; i<4; ++i) extra_field95_1[i] = other.extra_field95_1[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType95& other) const { return id < other.id; }
    bool operator==(const TestType95& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 96
struct TestType96 {
    char unique_data[99];
    int id;
    char** extra_field96_0;
    double padding[3];
    TestType96()
        : id(96), extra_field96_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<99; ++i) unique_data[i] = (i+96) % 256;
        for(int i=0; i<3; ++i) padding[i] = 96 + i * 0.1;
    }
    TestType96(const TestType96& other) {
        id = other.id + 96;
        for(int i=0; i<99; ++i) unique_data[i] = other.unique_data[i] + 96;
        extra_field96_0 = other.extra_field96_0;  // Shallow copy pointer
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType96& operator=(const TestType96& other) {
        if(this != &other) {
            id = other.id + 96;
            for(int i=0; i<99; ++i) unique_data[i] = other.unique_data[i] + 96;
            extra_field96_0 = other.extra_field96_0;  // Shallow copy pointer
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType96& other) const { return id < other.id; }
    bool operator==(const TestType96& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 97
struct TestType97 {
    char unique_data[104];
    int id;
    long extra_field97_0;
    long long extra_field97_1;
    double padding[3];
    TestType97()
        : id(97), extra_field97_0(97 * 1), extra_field97_1(97 * 2) {
        // Initialize unique_data array
        for(int i=0; i<104; ++i) unique_data[i] = (i+97) % 256;
        for(int i=0; i<3; ++i) padding[i] = 97 + i * 0.1;
    }
    TestType97(const TestType97& other) {
        id = other.id + 97;
        for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 97;
        extra_field97_0 = other.extra_field97_0 + 97;
        extra_field97_1 = other.extra_field97_1 + 97;
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType97& operator=(const TestType97& other) {
        if(this != &other) {
            id = other.id + 97;
            for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 97;
            extra_field97_0 = other.extra_field97_0 + 97;
            extra_field97_1 = other.extra_field97_1 + 97;
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType97& other) const { return id < other.id; }
    bool operator==(const TestType97& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 98
struct TestType98 {
    char unique_data[98];
    int id;
    double extra_field98_0;
    double* extra_field98_1[4];
    TestType98()
        : id(98), extra_field98_0(98 * 1) {
        // Initialize unique_data array
        for(int i=0; i<98; ++i) unique_data[i] = (i+98) % 256;
        for(int i=0; i<4; ++i) extra_field98_1[i] = nullptr;
    }
    TestType98(const TestType98& other) {
        id = other.id + 98;
        for(int i=0; i<98; ++i) unique_data[i] = other.unique_data[i] + 98;
        extra_field98_0 = other.extra_field98_0 + 98;
        for(int i=0; i<4; ++i) extra_field98_1[i] = other.extra_field98_1[i];
    }
    TestType98& operator=(const TestType98& other) {
        if(this != &other) {
            id = other.id + 98;
            for(int i=0; i<98; ++i) unique_data[i] = other.unique_data[i] + 98;
            extra_field98_0 = other.extra_field98_0 + 98;
            for(int i=0; i<4; ++i) extra_field98_1[i] = other.extra_field98_1[i];
        }
        return *this;
    }
    bool operator<(const TestType98& other) const { return id < other.id; }
    bool operator==(const TestType98& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 99
struct TestType99 {
    char unique_data[102];
    int id;
    long* extra_field99_0;
    char extra_field99_1;
    double* extra_field99_2;
    long double extra_field99_3;
    char random_padding[4];
    TestType99()
        : id(99), extra_field99_0(nullptr), extra_field99_1(99 * 2), extra_field99_2(nullptr), extra_field99_3(99 * 4) {
        // Initialize unique_data array
        for(int i=0; i<102; ++i) unique_data[i] = (i+99) % 256;
        for(int i=0; i<4; ++i) random_padding[i] = (99 + i) % 128;
    }
    TestType99(const TestType99& other) {
        id = other.id + 99;
        for(int i=0; i<102; ++i) unique_data[i] = other.unique_data[i] + 99;
        extra_field99_0 = other.extra_field99_0;  // Shallow copy pointer
        extra_field99_1 = other.extra_field99_1 + 99;
        extra_field99_2 = other.extra_field99_2;  // Shallow copy pointer
        extra_field99_3 = other.extra_field99_3 + 99;
        for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType99& operator=(const TestType99& other) {
        if(this != &other) {
            id = other.id + 99;
            for(int i=0; i<102; ++i) unique_data[i] = other.unique_data[i] + 99;
            extra_field99_0 = other.extra_field99_0;  // Shallow copy pointer
            extra_field99_1 = other.extra_field99_1 + 99;
            extra_field99_2 = other.extra_field99_2;  // Shallow copy pointer
            extra_field99_3 = other.extra_field99_3 + 99;
            for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType99& other) const { return id < other.id; }
    bool operator==(const TestType99& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 100
struct TestType100 {
    char unique_data[104];
    int id;
    unsigned int extra_field100_0;
    double padding[1];
    TestType100()
        : id(100), extra_field100_0(100 * 1) {
        // Initialize unique_data array
        for(int i=0; i<104; ++i) unique_data[i] = (i+100) % 256;
        for(int i=0; i<1; ++i) padding[i] = 100 + i * 0.1;
    }
    TestType100(const TestType100& other) {
        id = other.id + 100;
        for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 100;
        extra_field100_0 = other.extra_field100_0 + 100;
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType100& operator=(const TestType100& other) {
        if(this != &other) {
            id = other.id + 100;
            for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 100;
            extra_field100_0 = other.extra_field100_0 + 100;
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType100& other) const { return id < other.id; }
    bool operator==(const TestType100& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 101
struct TestType101 {
    char unique_data[106];
    int id;
    int** extra_field101_0;
    short extra_field101_1[4];
    float extra_field101_2[4];
    double padding[2];
    TestType101()
        : id(101), extra_field101_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<106; ++i) unique_data[i] = (i+101) % 256;
        for(int i=0; i<4; ++i) extra_field101_1[i] = 101 + i;
        for(int i=0; i<4; ++i) extra_field101_2[i] = 101 + i;
        for(int i=0; i<2; ++i) padding[i] = 101 + i * 0.1;
    }
    TestType101(const TestType101& other) {
        id = other.id + 101;
        for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 101;
        extra_field101_0 = other.extra_field101_0;  // Shallow copy pointer
        for(int i=0; i<4; ++i) extra_field101_1[i] = other.extra_field101_1[i];
        for(int i=0; i<4; ++i) extra_field101_2[i] = other.extra_field101_2[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType101& operator=(const TestType101& other) {
        if(this != &other) {
            id = other.id + 101;
            for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 101;
            extra_field101_0 = other.extra_field101_0;  // Shallow copy pointer
            for(int i=0; i<4; ++i) extra_field101_1[i] = other.extra_field101_1[i];
            for(int i=0; i<4; ++i) extra_field101_2[i] = other.extra_field101_2[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType101& other) const { return id < other.id; }
    bool operator==(const TestType101& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 102
struct TestType102 {
    char unique_data[104];
    int id;
    unsigned char extra_field102_0[6];
    char** extra_field102_1[3];
    int** extra_field102_2;
    char** extra_field102_3;
    TestType102()
        : id(102), extra_field102_2(nullptr), extra_field102_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<104; ++i) unique_data[i] = (i+102) % 256;
        for(int i=0; i<6; ++i) extra_field102_0[i] = 102 + i;
        for(int i=0; i<3; ++i) extra_field102_1[i] = nullptr;
    }
    TestType102(const TestType102& other) {
        id = other.id + 102;
        for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 102;
        for(int i=0; i<6; ++i) extra_field102_0[i] = other.extra_field102_0[i];
        for(int i=0; i<3; ++i) extra_field102_1[i] = other.extra_field102_1[i];
        extra_field102_2 = other.extra_field102_2;  // Shallow copy pointer
        extra_field102_3 = other.extra_field102_3;  // Shallow copy pointer
    }
    TestType102& operator=(const TestType102& other) {
        if(this != &other) {
            id = other.id + 102;
            for(int i=0; i<104; ++i) unique_data[i] = other.unique_data[i] + 102;
            for(int i=0; i<6; ++i) extra_field102_0[i] = other.extra_field102_0[i];
            for(int i=0; i<3; ++i) extra_field102_1[i] = other.extra_field102_1[i];
            extra_field102_2 = other.extra_field102_2;  // Shallow copy pointer
            extra_field102_3 = other.extra_field102_3;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType102& other) const { return id < other.id; }
    bool operator==(const TestType102& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 103
struct TestType103 {
    char unique_data[112];
    int id;
    void* extra_field103_0;
    char** extra_field103_1;
    int* extra_field103_2;
    double* extra_field103_3[3];
    unsigned char extra_field103_4;
    char random_padding[4];
    TestType103()
        : id(103), extra_field103_0(nullptr), extra_field103_1(nullptr), extra_field103_2(nullptr), extra_field103_4(103 * 5) {
        // Initialize unique_data array
        for(int i=0; i<112; ++i) unique_data[i] = (i+103) % 256;
        for(int i=0; i<3; ++i) extra_field103_3[i] = nullptr;
        for(int i=0; i<4; ++i) random_padding[i] = (103 + i) % 128;
    }
    TestType103(const TestType103& other) {
        id = other.id + 103;
        for(int i=0; i<112; ++i) unique_data[i] = other.unique_data[i] + 103;
        extra_field103_0 = other.extra_field103_0;  // Shallow copy pointer
        extra_field103_1 = other.extra_field103_1;  // Shallow copy pointer
        extra_field103_2 = other.extra_field103_2;  // Shallow copy pointer
        for(int i=0; i<3; ++i) extra_field103_3[i] = other.extra_field103_3[i];
        extra_field103_4 = other.extra_field103_4 + 103;
        for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType103& operator=(const TestType103& other) {
        if(this != &other) {
            id = other.id + 103;
            for(int i=0; i<112; ++i) unique_data[i] = other.unique_data[i] + 103;
            extra_field103_0 = other.extra_field103_0;  // Shallow copy pointer
            extra_field103_1 = other.extra_field103_1;  // Shallow copy pointer
            extra_field103_2 = other.extra_field103_2;  // Shallow copy pointer
            for(int i=0; i<3; ++i) extra_field103_3[i] = other.extra_field103_3[i];
            extra_field103_4 = other.extra_field103_4 + 103;
            for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType103& other) const { return id < other.id; }
    bool operator==(const TestType103& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 104
struct TestType104 {
    char unique_data[107];
    int id;
    int* extra_field104_0;
    double extra_field104_1;
    char random_padding[2];
    TestType104()
        : id(104), extra_field104_0(nullptr), extra_field104_1(104 * 2) {
        // Initialize unique_data array
        for(int i=0; i<107; ++i) unique_data[i] = (i+104) % 256;
        for(int i=0; i<2; ++i) random_padding[i] = (104 + i) % 128;
    }
    TestType104(const TestType104& other) {
        id = other.id + 104;
        for(int i=0; i<107; ++i) unique_data[i] = other.unique_data[i] + 104;
        extra_field104_0 = other.extra_field104_0;  // Shallow copy pointer
        extra_field104_1 = other.extra_field104_1 + 104;
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType104& operator=(const TestType104& other) {
        if(this != &other) {
            id = other.id + 104;
            for(int i=0; i<107; ++i) unique_data[i] = other.unique_data[i] + 104;
            extra_field104_0 = other.extra_field104_0;  // Shallow copy pointer
            extra_field104_1 = other.extra_field104_1 + 104;
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType104& other) const { return id < other.id; }
    bool operator==(const TestType104& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 105
struct TestType105 {
    char unique_data[105];
    int id;
    long long extra_field105_0;
    float* extra_field105_1[5];
    char random_padding[2];
    TestType105()
        : id(105), extra_field105_0(105 * 1) {
        // Initialize unique_data array
        for(int i=0; i<105; ++i) unique_data[i] = (i+105) % 256;
        for(int i=0; i<5; ++i) extra_field105_1[i] = nullptr;
        for(int i=0; i<2; ++i) random_padding[i] = (105 + i) % 128;
    }
    TestType105(const TestType105& other) {
        id = other.id + 105;
        for(int i=0; i<105; ++i) unique_data[i] = other.unique_data[i] + 105;
        extra_field105_0 = other.extra_field105_0 + 105;
        for(int i=0; i<5; ++i) extra_field105_1[i] = other.extra_field105_1[i];
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType105& operator=(const TestType105& other) {
        if(this != &other) {
            id = other.id + 105;
            for(int i=0; i<105; ++i) unique_data[i] = other.unique_data[i] + 105;
            extra_field105_0 = other.extra_field105_0 + 105;
            for(int i=0; i<5; ++i) extra_field105_1[i] = other.extra_field105_1[i];
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType105& other) const { return id < other.id; }
    bool operator==(const TestType105& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 106
struct TestType106 {
    char unique_data[106];
    int id;
    double extra_field106_0;
    double* extra_field106_1[4];
    double padding[2];
    TestType106()
        : id(106), extra_field106_0(106 * 1) {
        // Initialize unique_data array
        for(int i=0; i<106; ++i) unique_data[i] = (i+106) % 256;
        for(int i=0; i<4; ++i) extra_field106_1[i] = nullptr;
        for(int i=0; i<2; ++i) padding[i] = 106 + i * 0.1;
    }
    TestType106(const TestType106& other) {
        id = other.id + 106;
        for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 106;
        extra_field106_0 = other.extra_field106_0 + 106;
        for(int i=0; i<4; ++i) extra_field106_1[i] = other.extra_field106_1[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType106& operator=(const TestType106& other) {
        if(this != &other) {
            id = other.id + 106;
            for(int i=0; i<106; ++i) unique_data[i] = other.unique_data[i] + 106;
            extra_field106_0 = other.extra_field106_0 + 106;
            for(int i=0; i<4; ++i) extra_field106_1[i] = other.extra_field106_1[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType106& other) const { return id < other.id; }
    bool operator==(const TestType106& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 107
struct TestType107 {
    char unique_data[107];
    int id;
    long double extra_field107_0;
    unsigned short extra_field107_1;
    double padding[3];
    TestType107()
        : id(107), extra_field107_0(107 * 1), extra_field107_1(107 * 2) {
        // Initialize unique_data array
        for(int i=0; i<107; ++i) unique_data[i] = (i+107) % 256;
        for(int i=0; i<3; ++i) padding[i] = 107 + i * 0.1;
    }
    TestType107(const TestType107& other) {
        id = other.id + 107;
        for(int i=0; i<107; ++i) unique_data[i] = other.unique_data[i] + 107;
        extra_field107_0 = other.extra_field107_0 + 107;
        extra_field107_1 = other.extra_field107_1 + 107;
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType107& operator=(const TestType107& other) {
        if(this != &other) {
            id = other.id + 107;
            for(int i=0; i<107; ++i) unique_data[i] = other.unique_data[i] + 107;
            extra_field107_0 = other.extra_field107_0 + 107;
            extra_field107_1 = other.extra_field107_1 + 107;
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType107& other) const { return id < other.id; }
    bool operator==(const TestType107& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 108
struct TestType108 {
    char unique_data[110];
    int id;
    float extra_field108_0;
    unsigned long extra_field108_1;
    char* extra_field108_2[3];
    double* extra_field108_3;
    char random_padding[5];
    TestType108()
        : id(108), extra_field108_0(108 * 1), extra_field108_1(108 * 2), extra_field108_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<110; ++i) unique_data[i] = (i+108) % 256;
        for(int i=0; i<3; ++i) extra_field108_2[i] = nullptr;
        for(int i=0; i<5; ++i) random_padding[i] = (108 + i) % 128;
    }
    TestType108(const TestType108& other) {
        id = other.id + 108;
        for(int i=0; i<110; ++i) unique_data[i] = other.unique_data[i] + 108;
        extra_field108_0 = other.extra_field108_0 + 108;
        extra_field108_1 = other.extra_field108_1 + 108;
        for(int i=0; i<3; ++i) extra_field108_2[i] = other.extra_field108_2[i];
        extra_field108_3 = other.extra_field108_3;  // Shallow copy pointer
        for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType108& operator=(const TestType108& other) {
        if(this != &other) {
            id = other.id + 108;
            for(int i=0; i<110; ++i) unique_data[i] = other.unique_data[i] + 108;
            extra_field108_0 = other.extra_field108_0 + 108;
            extra_field108_1 = other.extra_field108_1 + 108;
            for(int i=0; i<3; ++i) extra_field108_2[i] = other.extra_field108_2[i];
            extra_field108_3 = other.extra_field108_3;  // Shallow copy pointer
            for(int i=0; i<5; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType108& other) const { return id < other.id; }
    bool operator==(const TestType108& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 109
struct TestType109 {
    char unique_data[111];
    int id;
    double extra_field109_0;
    int** extra_field109_1;
    char random_padding[1];
    TestType109()
        : id(109), extra_field109_0(109 * 1), extra_field109_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<111; ++i) unique_data[i] = (i+109) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (109 + i) % 128;
    }
    TestType109(const TestType109& other) {
        id = other.id + 109;
        for(int i=0; i<111; ++i) unique_data[i] = other.unique_data[i] + 109;
        extra_field109_0 = other.extra_field109_0 + 109;
        extra_field109_1 = other.extra_field109_1;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType109& operator=(const TestType109& other) {
        if(this != &other) {
            id = other.id + 109;
            for(int i=0; i<111; ++i) unique_data[i] = other.unique_data[i] + 109;
            extra_field109_0 = other.extra_field109_0 + 109;
            extra_field109_1 = other.extra_field109_1;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType109& other) const { return id < other.id; }
    bool operator==(const TestType109& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 110
struct TestType110 {
    char unique_data[111];
    int id;
    unsigned long long extra_field110_0;
    double padding[1];
    TestType110()
        : id(110), extra_field110_0(110 * 1) {
        // Initialize unique_data array
        for(int i=0; i<111; ++i) unique_data[i] = (i+110) % 256;
        for(int i=0; i<1; ++i) padding[i] = 110 + i * 0.1;
    }
    TestType110(const TestType110& other) {
        id = other.id + 110;
        for(int i=0; i<111; ++i) unique_data[i] = other.unique_data[i] + 110;
        extra_field110_0 = other.extra_field110_0 + 110;
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType110& operator=(const TestType110& other) {
        if(this != &other) {
            id = other.id + 110;
            for(int i=0; i<111; ++i) unique_data[i] = other.unique_data[i] + 110;
            extra_field110_0 = other.extra_field110_0 + 110;
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType110& other) const { return id < other.id; }
    bool operator==(const TestType110& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 111
struct TestType111 {
    char unique_data[127];
    int id;
    unsigned short extra_field111_0;
    TestType111()
        : id(111), extra_field111_0(111 * 1) {
        // Initialize unique_data array
        for(int i=0; i<127; ++i) unique_data[i] = (i+111) % 256;
    }
    TestType111(const TestType111& other) {
        id = other.id + 111;
        for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 111;
        extra_field111_0 = other.extra_field111_0 + 111;
    }
    TestType111& operator=(const TestType111& other) {
        if(this != &other) {
            id = other.id + 111;
            for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 111;
            extra_field111_0 = other.extra_field111_0 + 111;
        }
        return *this;
    }
    bool operator<(const TestType111& other) const { return id < other.id; }
    bool operator==(const TestType111& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 112
struct TestType112 {
    char unique_data[123];
    int id;
    long double extra_field112_0;
    int extra_field112_1;
    unsigned short extra_field112_2;
    unsigned long long extra_field112_3;
    float extra_field112_4[2];
    TestType112()
        : id(112), extra_field112_0(112 * 1), extra_field112_1(112 * 2), extra_field112_2(112 * 3), extra_field112_3(112 * 4) {
        // Initialize unique_data array
        for(int i=0; i<123; ++i) unique_data[i] = (i+112) % 256;
        for(int i=0; i<2; ++i) extra_field112_4[i] = 112 + i;
    }
    TestType112(const TestType112& other) {
        id = other.id + 112;
        for(int i=0; i<123; ++i) unique_data[i] = other.unique_data[i] + 112;
        extra_field112_0 = other.extra_field112_0 + 112;
        extra_field112_1 = other.extra_field112_1 + 112;
        extra_field112_2 = other.extra_field112_2 + 112;
        extra_field112_3 = other.extra_field112_3 + 112;
        for(int i=0; i<2; ++i) extra_field112_4[i] = other.extra_field112_4[i];
    }
    TestType112& operator=(const TestType112& other) {
        if(this != &other) {
            id = other.id + 112;
            for(int i=0; i<123; ++i) unique_data[i] = other.unique_data[i] + 112;
            extra_field112_0 = other.extra_field112_0 + 112;
            extra_field112_1 = other.extra_field112_1 + 112;
            extra_field112_2 = other.extra_field112_2 + 112;
            extra_field112_3 = other.extra_field112_3 + 112;
            for(int i=0; i<2; ++i) extra_field112_4[i] = other.extra_field112_4[i];
        }
        return *this;
    }
    bool operator<(const TestType112& other) const { return id < other.id; }
    bool operator==(const TestType112& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 113
struct TestType113 {
    char unique_data[129];
    int id;
    float* extra_field113_0[3];
    double padding[1];
    TestType113()
        : id(113) {
        // Initialize unique_data array
        for(int i=0; i<129; ++i) unique_data[i] = (i+113) % 256;
        for(int i=0; i<3; ++i) extra_field113_0[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 113 + i * 0.1;
    }
    TestType113(const TestType113& other) {
        id = other.id + 113;
        for(int i=0; i<129; ++i) unique_data[i] = other.unique_data[i] + 113;
        for(int i=0; i<3; ++i) extra_field113_0[i] = other.extra_field113_0[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType113& operator=(const TestType113& other) {
        if(this != &other) {
            id = other.id + 113;
            for(int i=0; i<129; ++i) unique_data[i] = other.unique_data[i] + 113;
            for(int i=0; i<3; ++i) extra_field113_0[i] = other.extra_field113_0[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType113& other) const { return id < other.id; }
    bool operator==(const TestType113& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 114
struct TestType114 {
    char unique_data[114];
    int id;
    unsigned int extra_field114_0;
    double padding[5];
    TestType114()
        : id(114), extra_field114_0(114 * 1) {
        // Initialize unique_data array
        for(int i=0; i<114; ++i) unique_data[i] = (i+114) % 256;
        for(int i=0; i<5; ++i) padding[i] = 114 + i * 0.1;
    }
    TestType114(const TestType114& other) {
        id = other.id + 114;
        for(int i=0; i<114; ++i) unique_data[i] = other.unique_data[i] + 114;
        extra_field114_0 = other.extra_field114_0 + 114;
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType114& operator=(const TestType114& other) {
        if(this != &other) {
            id = other.id + 114;
            for(int i=0; i<114; ++i) unique_data[i] = other.unique_data[i] + 114;
            extra_field114_0 = other.extra_field114_0 + 114;
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType114& other) const { return id < other.id; }
    bool operator==(const TestType114& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 115
struct TestType115 {
    char unique_data[119];
    int id;
    long* extra_field115_0;
    unsigned long extra_field115_1;
    unsigned int extra_field115_2;
    int** extra_field115_3;
    long* extra_field115_4[1];
    double padding[1];
    TestType115()
        : id(115), extra_field115_0(nullptr), extra_field115_1(115 * 2), extra_field115_2(115 * 3), extra_field115_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<119; ++i) unique_data[i] = (i+115) % 256;
        for(int i=0; i<1; ++i) extra_field115_4[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 115 + i * 0.1;
    }
    TestType115(const TestType115& other) {
        id = other.id + 115;
        for(int i=0; i<119; ++i) unique_data[i] = other.unique_data[i] + 115;
        extra_field115_0 = other.extra_field115_0;  // Shallow copy pointer
        extra_field115_1 = other.extra_field115_1 + 115;
        extra_field115_2 = other.extra_field115_2 + 115;
        extra_field115_3 = other.extra_field115_3;  // Shallow copy pointer
        for(int i=0; i<1; ++i) extra_field115_4[i] = other.extra_field115_4[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType115& operator=(const TestType115& other) {
        if(this != &other) {
            id = other.id + 115;
            for(int i=0; i<119; ++i) unique_data[i] = other.unique_data[i] + 115;
            extra_field115_0 = other.extra_field115_0;  // Shallow copy pointer
            extra_field115_1 = other.extra_field115_1 + 115;
            extra_field115_2 = other.extra_field115_2 + 115;
            extra_field115_3 = other.extra_field115_3;  // Shallow copy pointer
            for(int i=0; i<1; ++i) extra_field115_4[i] = other.extra_field115_4[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType115& other) const { return id < other.id; }
    bool operator==(const TestType115& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 116
struct TestType116 {
    char unique_data[127];
    int id;
    double* extra_field116_0;
    double* extra_field116_1;
    char random_padding[4];
    TestType116()
        : id(116), extra_field116_0(nullptr), extra_field116_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<127; ++i) unique_data[i] = (i+116) % 256;
        for(int i=0; i<4; ++i) random_padding[i] = (116 + i) % 128;
    }
    TestType116(const TestType116& other) {
        id = other.id + 116;
        for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 116;
        extra_field116_0 = other.extra_field116_0;  // Shallow copy pointer
        extra_field116_1 = other.extra_field116_1;  // Shallow copy pointer
        for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType116& operator=(const TestType116& other) {
        if(this != &other) {
            id = other.id + 116;
            for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 116;
            extra_field116_0 = other.extra_field116_0;  // Shallow copy pointer
            extra_field116_1 = other.extra_field116_1;  // Shallow copy pointer
            for(int i=0; i<4; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType116& other) const { return id < other.id; }
    bool operator==(const TestType116& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 117
struct TestType117 {
    char unique_data[117];
    int id;
    double extra_field117_0;
    double padding[3];
    TestType117()
        : id(117), extra_field117_0(117 * 1) {
        // Initialize unique_data array
        for(int i=0; i<117; ++i) unique_data[i] = (i+117) % 256;
        for(int i=0; i<3; ++i) padding[i] = 117 + i * 0.1;
    }
    TestType117(const TestType117& other) {
        id = other.id + 117;
        for(int i=0; i<117; ++i) unique_data[i] = other.unique_data[i] + 117;
        extra_field117_0 = other.extra_field117_0 + 117;
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType117& operator=(const TestType117& other) {
        if(this != &other) {
            id = other.id + 117;
            for(int i=0; i<117; ++i) unique_data[i] = other.unique_data[i] + 117;
            extra_field117_0 = other.extra_field117_0 + 117;
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType117& other) const { return id < other.id; }
    bool operator==(const TestType117& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 118
struct TestType118 {
    char unique_data[118];
    int id;
    long long extra_field118_0;
    int extra_field118_1;
    double padding[7];
    TestType118()
        : id(118), extra_field118_0(118 * 1), extra_field118_1(118 * 2) {
        // Initialize unique_data array
        for(int i=0; i<118; ++i) unique_data[i] = (i+118) % 256;
        for(int i=0; i<7; ++i) padding[i] = 118 + i * 0.1;
    }
    TestType118(const TestType118& other) {
        id = other.id + 118;
        for(int i=0; i<118; ++i) unique_data[i] = other.unique_data[i] + 118;
        extra_field118_0 = other.extra_field118_0 + 118;
        extra_field118_1 = other.extra_field118_1 + 118;
        for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType118& operator=(const TestType118& other) {
        if(this != &other) {
            id = other.id + 118;
            for(int i=0; i<118; ++i) unique_data[i] = other.unique_data[i] + 118;
            extra_field118_0 = other.extra_field118_0 + 118;
            extra_field118_1 = other.extra_field118_1 + 118;
            for(int i=0; i<7; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType118& other) const { return id < other.id; }
    bool operator==(const TestType118& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 119
struct TestType119 {
    char unique_data[135];
    int id;
    long extra_field119_0[9];
    short extra_field119_1;
    double padding[4];
    TestType119()
        : id(119), extra_field119_1(119 * 2) {
        // Initialize unique_data array
        for(int i=0; i<135; ++i) unique_data[i] = (i+119) % 256;
        for(int i=0; i<9; ++i) extra_field119_0[i] = 119 + i;
        for(int i=0; i<4; ++i) padding[i] = 119 + i * 0.1;
    }
    TestType119(const TestType119& other) {
        id = other.id + 119;
        for(int i=0; i<135; ++i) unique_data[i] = other.unique_data[i] + 119;
        for(int i=0; i<9; ++i) extra_field119_0[i] = other.extra_field119_0[i];
        extra_field119_1 = other.extra_field119_1 + 119;
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType119& operator=(const TestType119& other) {
        if(this != &other) {
            id = other.id + 119;
            for(int i=0; i<135; ++i) unique_data[i] = other.unique_data[i] + 119;
            for(int i=0; i<9; ++i) extra_field119_0[i] = other.extra_field119_0[i];
            extra_field119_1 = other.extra_field119_1 + 119;
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType119& other) const { return id < other.id; }
    bool operator==(const TestType119& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 120
struct TestType120 {
    char unique_data[127];
    int id;
    unsigned short extra_field120_0;
    short extra_field120_1[9];
    int** extra_field120_2;
    char* extra_field120_3[5];
    int extra_field120_4;
    double padding[1];
    TestType120()
        : id(120), extra_field120_0(120 * 1), extra_field120_2(nullptr), extra_field120_4(120 * 5) {
        // Initialize unique_data array
        for(int i=0; i<127; ++i) unique_data[i] = (i+120) % 256;
        for(int i=0; i<9; ++i) extra_field120_1[i] = 120 + i;
        for(int i=0; i<5; ++i) extra_field120_3[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 120 + i * 0.1;
    }
    TestType120(const TestType120& other) {
        id = other.id + 120;
        for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 120;
        extra_field120_0 = other.extra_field120_0 + 120;
        for(int i=0; i<9; ++i) extra_field120_1[i] = other.extra_field120_1[i];
        extra_field120_2 = other.extra_field120_2;  // Shallow copy pointer
        for(int i=0; i<5; ++i) extra_field120_3[i] = other.extra_field120_3[i];
        extra_field120_4 = other.extra_field120_4 + 120;
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType120& operator=(const TestType120& other) {
        if(this != &other) {
            id = other.id + 120;
            for(int i=0; i<127; ++i) unique_data[i] = other.unique_data[i] + 120;
            extra_field120_0 = other.extra_field120_0 + 120;
            for(int i=0; i<9; ++i) extra_field120_1[i] = other.extra_field120_1[i];
            extra_field120_2 = other.extra_field120_2;  // Shallow copy pointer
            for(int i=0; i<5; ++i) extra_field120_3[i] = other.extra_field120_3[i];
            extra_field120_4 = other.extra_field120_4 + 120;
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType120& other) const { return id < other.id; }
    bool operator==(const TestType120& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 121
struct TestType121 {
    char unique_data[136];
    int id;
    void* extra_field121_0;
    unsigned int extra_field121_1[1];
    void* extra_field121_2;
    unsigned int extra_field121_3[3];
    unsigned long extra_field121_4;
    TestType121()
        : id(121), extra_field121_0(nullptr), extra_field121_2(nullptr), extra_field121_4(121 * 5) {
        // Initialize unique_data array
        for(int i=0; i<136; ++i) unique_data[i] = (i+121) % 256;
        for(int i=0; i<1; ++i) extra_field121_1[i] = 121 + i;
        for(int i=0; i<3; ++i) extra_field121_3[i] = 121 + i;
    }
    TestType121(const TestType121& other) {
        id = other.id + 121;
        for(int i=0; i<136; ++i) unique_data[i] = other.unique_data[i] + 121;
        extra_field121_0 = other.extra_field121_0;  // Shallow copy pointer
        for(int i=0; i<1; ++i) extra_field121_1[i] = other.extra_field121_1[i];
        extra_field121_2 = other.extra_field121_2;  // Shallow copy pointer
        for(int i=0; i<3; ++i) extra_field121_3[i] = other.extra_field121_3[i];
        extra_field121_4 = other.extra_field121_4 + 121;
    }
    TestType121& operator=(const TestType121& other) {
        if(this != &other) {
            id = other.id + 121;
            for(int i=0; i<136; ++i) unique_data[i] = other.unique_data[i] + 121;
            extra_field121_0 = other.extra_field121_0;  // Shallow copy pointer
            for(int i=0; i<1; ++i) extra_field121_1[i] = other.extra_field121_1[i];
            extra_field121_2 = other.extra_field121_2;  // Shallow copy pointer
            for(int i=0; i<3; ++i) extra_field121_3[i] = other.extra_field121_3[i];
            extra_field121_4 = other.extra_field121_4 + 121;
        }
        return *this;
    }
    bool operator<(const TestType121& other) const { return id < other.id; }
    bool operator==(const TestType121& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 122
struct TestType122 {
    char unique_data[131];
    int id;
    unsigned short extra_field122_0;
    long* extra_field122_1[5];
    char* extra_field122_2;
    long long extra_field122_3[1];
    double padding[5];
    TestType122()
        : id(122), extra_field122_0(122 * 1), extra_field122_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<131; ++i) unique_data[i] = (i+122) % 256;
        for(int i=0; i<5; ++i) extra_field122_1[i] = nullptr;
        for(int i=0; i<1; ++i) extra_field122_3[i] = 122 + i;
        for(int i=0; i<5; ++i) padding[i] = 122 + i * 0.1;
    }
    TestType122(const TestType122& other) {
        id = other.id + 122;
        for(int i=0; i<131; ++i) unique_data[i] = other.unique_data[i] + 122;
        extra_field122_0 = other.extra_field122_0 + 122;
        for(int i=0; i<5; ++i) extra_field122_1[i] = other.extra_field122_1[i];
        extra_field122_2 = other.extra_field122_2;  // Shallow copy pointer
        for(int i=0; i<1; ++i) extra_field122_3[i] = other.extra_field122_3[i];
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType122& operator=(const TestType122& other) {
        if(this != &other) {
            id = other.id + 122;
            for(int i=0; i<131; ++i) unique_data[i] = other.unique_data[i] + 122;
            extra_field122_0 = other.extra_field122_0 + 122;
            for(int i=0; i<5; ++i) extra_field122_1[i] = other.extra_field122_1[i];
            extra_field122_2 = other.extra_field122_2;  // Shallow copy pointer
            for(int i=0; i<1; ++i) extra_field122_3[i] = other.extra_field122_3[i];
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType122& other) const { return id < other.id; }
    bool operator==(const TestType122& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 123
struct TestType123 {
    char unique_data[125];
    int id;
    long double extra_field123_0;
    long double extra_field123_1;
    long* extra_field123_2;
    TestType123()
        : id(123), extra_field123_0(123 * 1), extra_field123_1(123 * 2), extra_field123_2(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<125; ++i) unique_data[i] = (i+123) % 256;
    }
    TestType123(const TestType123& other) {
        id = other.id + 123;
        for(int i=0; i<125; ++i) unique_data[i] = other.unique_data[i] + 123;
        extra_field123_0 = other.extra_field123_0 + 123;
        extra_field123_1 = other.extra_field123_1 + 123;
        extra_field123_2 = other.extra_field123_2;  // Shallow copy pointer
    }
    TestType123& operator=(const TestType123& other) {
        if(this != &other) {
            id = other.id + 123;
            for(int i=0; i<125; ++i) unique_data[i] = other.unique_data[i] + 123;
            extra_field123_0 = other.extra_field123_0 + 123;
            extra_field123_1 = other.extra_field123_1 + 123;
            extra_field123_2 = other.extra_field123_2;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType123& other) const { return id < other.id; }
    bool operator==(const TestType123& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 124
struct TestType124 {
    char unique_data[125];
    int id;
    double* extra_field124_0[3];
    unsigned short extra_field124_1;
    TestType124()
        : id(124), extra_field124_1(124 * 2) {
        // Initialize unique_data array
        for(int i=0; i<125; ++i) unique_data[i] = (i+124) % 256;
        for(int i=0; i<3; ++i) extra_field124_0[i] = nullptr;
    }
    TestType124(const TestType124& other) {
        id = other.id + 124;
        for(int i=0; i<125; ++i) unique_data[i] = other.unique_data[i] + 124;
        for(int i=0; i<3; ++i) extra_field124_0[i] = other.extra_field124_0[i];
        extra_field124_1 = other.extra_field124_1 + 124;
    }
    TestType124& operator=(const TestType124& other) {
        if(this != &other) {
            id = other.id + 124;
            for(int i=0; i<125; ++i) unique_data[i] = other.unique_data[i] + 124;
            for(int i=0; i<3; ++i) extra_field124_0[i] = other.extra_field124_0[i];
            extra_field124_1 = other.extra_field124_1 + 124;
        }
        return *this;
    }
    bool operator<(const TestType124& other) const { return id < other.id; }
    bool operator==(const TestType124& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 125
struct TestType125 {
    char unique_data[131];
    int id;
    int* extra_field125_0[2];
    int extra_field125_1;
    short extra_field125_2;
    double padding[1];
    TestType125()
        : id(125), extra_field125_1(125 * 2), extra_field125_2(125 * 3) {
        // Initialize unique_data array
        for(int i=0; i<131; ++i) unique_data[i] = (i+125) % 256;
        for(int i=0; i<2; ++i) extra_field125_0[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 125 + i * 0.1;
    }
    TestType125(const TestType125& other) {
        id = other.id + 125;
        for(int i=0; i<131; ++i) unique_data[i] = other.unique_data[i] + 125;
        for(int i=0; i<2; ++i) extra_field125_0[i] = other.extra_field125_0[i];
        extra_field125_1 = other.extra_field125_1 + 125;
        extra_field125_2 = other.extra_field125_2 + 125;
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType125& operator=(const TestType125& other) {
        if(this != &other) {
            id = other.id + 125;
            for(int i=0; i<131; ++i) unique_data[i] = other.unique_data[i] + 125;
            for(int i=0; i<2; ++i) extra_field125_0[i] = other.extra_field125_0[i];
            extra_field125_1 = other.extra_field125_1 + 125;
            extra_field125_2 = other.extra_field125_2 + 125;
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType125& other) const { return id < other.id; }
    bool operator==(const TestType125& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 126
struct TestType126 {
    char unique_data[138];
    int id;
    int extra_field126_0[9];
    double padding[2];
    TestType126()
        : id(126) {
        // Initialize unique_data array
        for(int i=0; i<138; ++i) unique_data[i] = (i+126) % 256;
        for(int i=0; i<9; ++i) extra_field126_0[i] = 126 + i;
        for(int i=0; i<2; ++i) padding[i] = 126 + i * 0.1;
    }
    TestType126(const TestType126& other) {
        id = other.id + 126;
        for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 126;
        for(int i=0; i<9; ++i) extra_field126_0[i] = other.extra_field126_0[i];
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType126& operator=(const TestType126& other) {
        if(this != &other) {
            id = other.id + 126;
            for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 126;
            for(int i=0; i<9; ++i) extra_field126_0[i] = other.extra_field126_0[i];
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType126& other) const { return id < other.id; }
    bool operator==(const TestType126& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 127
struct TestType127 {
    char unique_data[142];
    int id;
    long double extra_field127_0;
    double* extra_field127_1;
    TestType127()
        : id(127), extra_field127_0(127 * 1), extra_field127_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<142; ++i) unique_data[i] = (i+127) % 256;
    }
    TestType127(const TestType127& other) {
        id = other.id + 127;
        for(int i=0; i<142; ++i) unique_data[i] = other.unique_data[i] + 127;
        extra_field127_0 = other.extra_field127_0 + 127;
        extra_field127_1 = other.extra_field127_1;  // Shallow copy pointer
    }
    TestType127& operator=(const TestType127& other) {
        if(this != &other) {
            id = other.id + 127;
            for(int i=0; i<142; ++i) unique_data[i] = other.unique_data[i] + 127;
            extra_field127_0 = other.extra_field127_0 + 127;
            extra_field127_1 = other.extra_field127_1;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType127& other) const { return id < other.id; }
    bool operator==(const TestType127& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 128
struct TestType128 {
    char unique_data[138];
    int id;
    double* extra_field128_0;
    int* extra_field128_1[5];
    char** extra_field128_2[2];
    long extra_field128_3[8];
    char random_padding[6];
    TestType128()
        : id(128), extra_field128_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<138; ++i) unique_data[i] = (i+128) % 256;
        for(int i=0; i<5; ++i) extra_field128_1[i] = nullptr;
        for(int i=0; i<2; ++i) extra_field128_2[i] = nullptr;
        for(int i=0; i<8; ++i) extra_field128_3[i] = 128 + i;
        for(int i=0; i<6; ++i) random_padding[i] = (128 + i) % 128;
    }
    TestType128(const TestType128& other) {
        id = other.id + 128;
        for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 128;
        extra_field128_0 = other.extra_field128_0;  // Shallow copy pointer
        for(int i=0; i<5; ++i) extra_field128_1[i] = other.extra_field128_1[i];
        for(int i=0; i<2; ++i) extra_field128_2[i] = other.extra_field128_2[i];
        for(int i=0; i<8; ++i) extra_field128_3[i] = other.extra_field128_3[i];
        for(int i=0; i<6; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType128& operator=(const TestType128& other) {
        if(this != &other) {
            id = other.id + 128;
            for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 128;
            extra_field128_0 = other.extra_field128_0;  // Shallow copy pointer
            for(int i=0; i<5; ++i) extra_field128_1[i] = other.extra_field128_1[i];
            for(int i=0; i<2; ++i) extra_field128_2[i] = other.extra_field128_2[i];
            for(int i=0; i<8; ++i) extra_field128_3[i] = other.extra_field128_3[i];
            for(int i=0; i<6; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType128& other) const { return id < other.id; }
    bool operator==(const TestType128& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 129
struct TestType129 {
    char unique_data[138];
    int id;
    int** extra_field129_0[1];
    int* extra_field129_1;
    unsigned short extra_field129_2;
    long long extra_field129_3[9];
    double padding[3];
    TestType129()
        : id(129), extra_field129_1(nullptr), extra_field129_2(129 * 3) {
        // Initialize unique_data array
        for(int i=0; i<138; ++i) unique_data[i] = (i+129) % 256;
        for(int i=0; i<1; ++i) extra_field129_0[i] = nullptr;
        for(int i=0; i<9; ++i) extra_field129_3[i] = 129 + i;
        for(int i=0; i<3; ++i) padding[i] = 129 + i * 0.1;
    }
    TestType129(const TestType129& other) {
        id = other.id + 129;
        for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 129;
        for(int i=0; i<1; ++i) extra_field129_0[i] = other.extra_field129_0[i];
        extra_field129_1 = other.extra_field129_1;  // Shallow copy pointer
        extra_field129_2 = other.extra_field129_2 + 129;
        for(int i=0; i<9; ++i) extra_field129_3[i] = other.extra_field129_3[i];
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType129& operator=(const TestType129& other) {
        if(this != &other) {
            id = other.id + 129;
            for(int i=0; i<138; ++i) unique_data[i] = other.unique_data[i] + 129;
            for(int i=0; i<1; ++i) extra_field129_0[i] = other.extra_field129_0[i];
            extra_field129_1 = other.extra_field129_1;  // Shallow copy pointer
            extra_field129_2 = other.extra_field129_2 + 129;
            for(int i=0; i<9; ++i) extra_field129_3[i] = other.extra_field129_3[i];
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType129& other) const { return id < other.id; }
    bool operator==(const TestType129& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 130
struct TestType130 {
    char unique_data[140];
    int id;
    int* extra_field130_0;
    double extra_field130_1;
    double extra_field130_2;
    char extra_field130_3;
    float extra_field130_4;
    TestType130()
        : id(130), extra_field130_0(nullptr), extra_field130_1(130 * 2), extra_field130_2(130 * 3), extra_field130_3(130 * 4), extra_field130_4(130 * 5) {
        // Initialize unique_data array
        for(int i=0; i<140; ++i) unique_data[i] = (i+130) % 256;
    }
    TestType130(const TestType130& other) {
        id = other.id + 130;
        for(int i=0; i<140; ++i) unique_data[i] = other.unique_data[i] + 130;
        extra_field130_0 = other.extra_field130_0;  // Shallow copy pointer
        extra_field130_1 = other.extra_field130_1 + 130;
        extra_field130_2 = other.extra_field130_2 + 130;
        extra_field130_3 = other.extra_field130_3 + 130;
        extra_field130_4 = other.extra_field130_4 + 130;
    }
    TestType130& operator=(const TestType130& other) {
        if(this != &other) {
            id = other.id + 130;
            for(int i=0; i<140; ++i) unique_data[i] = other.unique_data[i] + 130;
            extra_field130_0 = other.extra_field130_0;  // Shallow copy pointer
            extra_field130_1 = other.extra_field130_1 + 130;
            extra_field130_2 = other.extra_field130_2 + 130;
            extra_field130_3 = other.extra_field130_3 + 130;
            extra_field130_4 = other.extra_field130_4 + 130;
        }
        return *this;
    }
    bool operator<(const TestType130& other) const { return id < other.id; }
    bool operator==(const TestType130& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 131
struct TestType131 {
    char unique_data[146];
    int id;
    char extra_field131_0[8];
    char extra_field131_1[7];
    double padding[5];
    TestType131()
        : id(131) {
        // Initialize unique_data array
        for(int i=0; i<146; ++i) unique_data[i] = (i+131) % 256;
        for(int i=0; i<8; ++i) extra_field131_0[i] = 131 + i;
        for(int i=0; i<7; ++i) extra_field131_1[i] = 131 + i;
        for(int i=0; i<5; ++i) padding[i] = 131 + i * 0.1;
    }
    TestType131(const TestType131& other) {
        id = other.id + 131;
        for(int i=0; i<146; ++i) unique_data[i] = other.unique_data[i] + 131;
        for(int i=0; i<8; ++i) extra_field131_0[i] = other.extra_field131_0[i];
        for(int i=0; i<7; ++i) extra_field131_1[i] = other.extra_field131_1[i];
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType131& operator=(const TestType131& other) {
        if(this != &other) {
            id = other.id + 131;
            for(int i=0; i<146; ++i) unique_data[i] = other.unique_data[i] + 131;
            for(int i=0; i<8; ++i) extra_field131_0[i] = other.extra_field131_0[i];
            for(int i=0; i<7; ++i) extra_field131_1[i] = other.extra_field131_1[i];
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType131& other) const { return id < other.id; }
    bool operator==(const TestType131& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 132
struct TestType132 {
    char unique_data[143];
    int id;
    unsigned short extra_field132_0;
    unsigned char extra_field132_1[9];
    long double extra_field132_2;
    unsigned short extra_field132_3;
    double* extra_field132_4;
    TestType132()
        : id(132), extra_field132_0(132 * 1), extra_field132_2(132 * 3), extra_field132_3(132 * 4), extra_field132_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<143; ++i) unique_data[i] = (i+132) % 256;
        for(int i=0; i<9; ++i) extra_field132_1[i] = 132 + i;
    }
    TestType132(const TestType132& other) {
        id = other.id + 132;
        for(int i=0; i<143; ++i) unique_data[i] = other.unique_data[i] + 132;
        extra_field132_0 = other.extra_field132_0 + 132;
        for(int i=0; i<9; ++i) extra_field132_1[i] = other.extra_field132_1[i];
        extra_field132_2 = other.extra_field132_2 + 132;
        extra_field132_3 = other.extra_field132_3 + 132;
        extra_field132_4 = other.extra_field132_4;  // Shallow copy pointer
    }
    TestType132& operator=(const TestType132& other) {
        if(this != &other) {
            id = other.id + 132;
            for(int i=0; i<143; ++i) unique_data[i] = other.unique_data[i] + 132;
            extra_field132_0 = other.extra_field132_0 + 132;
            for(int i=0; i<9; ++i) extra_field132_1[i] = other.extra_field132_1[i];
            extra_field132_2 = other.extra_field132_2 + 132;
            extra_field132_3 = other.extra_field132_3 + 132;
            extra_field132_4 = other.extra_field132_4;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType132& other) const { return id < other.id; }
    bool operator==(const TestType132& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 133
struct TestType133 {
    char unique_data[150];
    int id;
    unsigned char extra_field133_0;
    int extra_field133_1[4];
    double padding[4];
    TestType133()
        : id(133), extra_field133_0(133 * 1) {
        // Initialize unique_data array
        for(int i=0; i<150; ++i) unique_data[i] = (i+133) % 256;
        for(int i=0; i<4; ++i) extra_field133_1[i] = 133 + i;
        for(int i=0; i<4; ++i) padding[i] = 133 + i * 0.1;
    }
    TestType133(const TestType133& other) {
        id = other.id + 133;
        for(int i=0; i<150; ++i) unique_data[i] = other.unique_data[i] + 133;
        extra_field133_0 = other.extra_field133_0 + 133;
        for(int i=0; i<4; ++i) extra_field133_1[i] = other.extra_field133_1[i];
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType133& operator=(const TestType133& other) {
        if(this != &other) {
            id = other.id + 133;
            for(int i=0; i<150; ++i) unique_data[i] = other.unique_data[i] + 133;
            extra_field133_0 = other.extra_field133_0 + 133;
            for(int i=0; i<4; ++i) extra_field133_1[i] = other.extra_field133_1[i];
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType133& other) const { return id < other.id; }
    bool operator==(const TestType133& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 134
struct TestType134 {
    char unique_data[139];
    int id;
    float* extra_field134_0[3];
    long extra_field134_1[3];
    unsigned long long extra_field134_2;
    char extra_field134_3;
    short extra_field134_4[3];
    double padding[1];
    TestType134()
        : id(134), extra_field134_2(134 * 3), extra_field134_3(134 * 4) {
        // Initialize unique_data array
        for(int i=0; i<139; ++i) unique_data[i] = (i+134) % 256;
        for(int i=0; i<3; ++i) extra_field134_0[i] = nullptr;
        for(int i=0; i<3; ++i) extra_field134_1[i] = 134 + i;
        for(int i=0; i<3; ++i) extra_field134_4[i] = 134 + i;
        for(int i=0; i<1; ++i) padding[i] = 134 + i * 0.1;
    }
    TestType134(const TestType134& other) {
        id = other.id + 134;
        for(int i=0; i<139; ++i) unique_data[i] = other.unique_data[i] + 134;
        for(int i=0; i<3; ++i) extra_field134_0[i] = other.extra_field134_0[i];
        for(int i=0; i<3; ++i) extra_field134_1[i] = other.extra_field134_1[i];
        extra_field134_2 = other.extra_field134_2 + 134;
        extra_field134_3 = other.extra_field134_3 + 134;
        for(int i=0; i<3; ++i) extra_field134_4[i] = other.extra_field134_4[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType134& operator=(const TestType134& other) {
        if(this != &other) {
            id = other.id + 134;
            for(int i=0; i<139; ++i) unique_data[i] = other.unique_data[i] + 134;
            for(int i=0; i<3; ++i) extra_field134_0[i] = other.extra_field134_0[i];
            for(int i=0; i<3; ++i) extra_field134_1[i] = other.extra_field134_1[i];
            extra_field134_2 = other.extra_field134_2 + 134;
            extra_field134_3 = other.extra_field134_3 + 134;
            for(int i=0; i<3; ++i) extra_field134_4[i] = other.extra_field134_4[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType134& other) const { return id < other.id; }
    bool operator==(const TestType134& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 135
struct TestType135 {
    char unique_data[139];
    int id;
    unsigned char extra_field135_0;
    void* extra_field135_1;
    unsigned short extra_field135_2;
    double padding[1];
    TestType135()
        : id(135), extra_field135_0(135 * 1), extra_field135_1(nullptr), extra_field135_2(135 * 3) {
        // Initialize unique_data array
        for(int i=0; i<139; ++i) unique_data[i] = (i+135) % 256;
        for(int i=0; i<1; ++i) padding[i] = 135 + i * 0.1;
    }
    TestType135(const TestType135& other) {
        id = other.id + 135;
        for(int i=0; i<139; ++i) unique_data[i] = other.unique_data[i] + 135;
        extra_field135_0 = other.extra_field135_0 + 135;
        extra_field135_1 = other.extra_field135_1;  // Shallow copy pointer
        extra_field135_2 = other.extra_field135_2 + 135;
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType135& operator=(const TestType135& other) {
        if(this != &other) {
            id = other.id + 135;
            for(int i=0; i<139; ++i) unique_data[i] = other.unique_data[i] + 135;
            extra_field135_0 = other.extra_field135_0 + 135;
            extra_field135_1 = other.extra_field135_1;  // Shallow copy pointer
            extra_field135_2 = other.extra_field135_2 + 135;
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType135& other) const { return id < other.id; }
    bool operator==(const TestType135& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 136
struct TestType136 {
    char unique_data[140];
    int id;
    long long extra_field136_0;
    float* extra_field136_1;
    char random_padding[6];
    TestType136()
        : id(136), extra_field136_0(136 * 1), extra_field136_1(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<140; ++i) unique_data[i] = (i+136) % 256;
        for(int i=0; i<6; ++i) random_padding[i] = (136 + i) % 128;
    }
    TestType136(const TestType136& other) {
        id = other.id + 136;
        for(int i=0; i<140; ++i) unique_data[i] = other.unique_data[i] + 136;
        extra_field136_0 = other.extra_field136_0 + 136;
        extra_field136_1 = other.extra_field136_1;  // Shallow copy pointer
        for(int i=0; i<6; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType136& operator=(const TestType136& other) {
        if(this != &other) {
            id = other.id + 136;
            for(int i=0; i<140; ++i) unique_data[i] = other.unique_data[i] + 136;
            extra_field136_0 = other.extra_field136_0 + 136;
            extra_field136_1 = other.extra_field136_1;  // Shallow copy pointer
            for(int i=0; i<6; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType136& other) const { return id < other.id; }
    bool operator==(const TestType136& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 137
struct TestType137 {
    char unique_data[144];
    int id;
    char** extra_field137_0;
    long double extra_field137_1;
    char random_padding[1];
    TestType137()
        : id(137), extra_field137_0(nullptr), extra_field137_1(137 * 2) {
        // Initialize unique_data array
        for(int i=0; i<144; ++i) unique_data[i] = (i+137) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (137 + i) % 128;
    }
    TestType137(const TestType137& other) {
        id = other.id + 137;
        for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 137;
        extra_field137_0 = other.extra_field137_0;  // Shallow copy pointer
        extra_field137_1 = other.extra_field137_1 + 137;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType137& operator=(const TestType137& other) {
        if(this != &other) {
            id = other.id + 137;
            for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 137;
            extra_field137_0 = other.extra_field137_0;  // Shallow copy pointer
            extra_field137_1 = other.extra_field137_1 + 137;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType137& other) const { return id < other.id; }
    bool operator==(const TestType137& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 138
struct TestType138 {
    char unique_data[144];
    int id;
    long long extra_field138_0;
    char extra_field138_1[10];
    int* extra_field138_2;
    int** extra_field138_3;
    int* extra_field138_4[5];
    TestType138()
        : id(138), extra_field138_0(138 * 1), extra_field138_2(nullptr), extra_field138_3(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<144; ++i) unique_data[i] = (i+138) % 256;
        for(int i=0; i<10; ++i) extra_field138_1[i] = 138 + i;
        for(int i=0; i<5; ++i) extra_field138_4[i] = nullptr;
    }
    TestType138(const TestType138& other) {
        id = other.id + 138;
        for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 138;
        extra_field138_0 = other.extra_field138_0 + 138;
        for(int i=0; i<10; ++i) extra_field138_1[i] = other.extra_field138_1[i];
        extra_field138_2 = other.extra_field138_2;  // Shallow copy pointer
        extra_field138_3 = other.extra_field138_3;  // Shallow copy pointer
        for(int i=0; i<5; ++i) extra_field138_4[i] = other.extra_field138_4[i];
    }
    TestType138& operator=(const TestType138& other) {
        if(this != &other) {
            id = other.id + 138;
            for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 138;
            extra_field138_0 = other.extra_field138_0 + 138;
            for(int i=0; i<10; ++i) extra_field138_1[i] = other.extra_field138_1[i];
            extra_field138_2 = other.extra_field138_2;  // Shallow copy pointer
            extra_field138_3 = other.extra_field138_3;  // Shallow copy pointer
            for(int i=0; i<5; ++i) extra_field138_4[i] = other.extra_field138_4[i];
        }
        return *this;
    }
    bool operator<(const TestType138& other) const { return id < other.id; }
    bool operator==(const TestType138& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 139
struct TestType139 {
    char unique_data[141];
    int id;
    char extra_field139_0;
    int** extra_field139_1[5];
    double padding[1];
    TestType139()
        : id(139), extra_field139_0(139 * 1) {
        // Initialize unique_data array
        for(int i=0; i<141; ++i) unique_data[i] = (i+139) % 256;
        for(int i=0; i<5; ++i) extra_field139_1[i] = nullptr;
        for(int i=0; i<1; ++i) padding[i] = 139 + i * 0.1;
    }
    TestType139(const TestType139& other) {
        id = other.id + 139;
        for(int i=0; i<141; ++i) unique_data[i] = other.unique_data[i] + 139;
        extra_field139_0 = other.extra_field139_0 + 139;
        for(int i=0; i<5; ++i) extra_field139_1[i] = other.extra_field139_1[i];
        for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType139& operator=(const TestType139& other) {
        if(this != &other) {
            id = other.id + 139;
            for(int i=0; i<141; ++i) unique_data[i] = other.unique_data[i] + 139;
            extra_field139_0 = other.extra_field139_0 + 139;
            for(int i=0; i<5; ++i) extra_field139_1[i] = other.extra_field139_1[i];
            for(int i=0; i<1; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType139& other) const { return id < other.id; }
    bool operator==(const TestType139& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 140
struct TestType140 {
    char unique_data[142];
    int id;
    float* extra_field140_0;
    char random_padding[1];
    TestType140()
        : id(140), extra_field140_0(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<142; ++i) unique_data[i] = (i+140) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (140 + i) % 128;
    }
    TestType140(const TestType140& other) {
        id = other.id + 140;
        for(int i=0; i<142; ++i) unique_data[i] = other.unique_data[i] + 140;
        extra_field140_0 = other.extra_field140_0;  // Shallow copy pointer
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType140& operator=(const TestType140& other) {
        if(this != &other) {
            id = other.id + 140;
            for(int i=0; i<142; ++i) unique_data[i] = other.unique_data[i] + 140;
            extra_field140_0 = other.extra_field140_0;  // Shallow copy pointer
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType140& other) const { return id < other.id; }
    bool operator==(const TestType140& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 141
struct TestType141 {
    char unique_data[157];
    int id;
    long extra_field141_0;
    void* extra_field141_1;
    float extra_field141_2;
    double padding[4];
    TestType141()
        : id(141), extra_field141_0(141 * 1), extra_field141_1(nullptr), extra_field141_2(141 * 3) {
        // Initialize unique_data array
        for(int i=0; i<157; ++i) unique_data[i] = (i+141) % 256;
        for(int i=0; i<4; ++i) padding[i] = 141 + i * 0.1;
    }
    TestType141(const TestType141& other) {
        id = other.id + 141;
        for(int i=0; i<157; ++i) unique_data[i] = other.unique_data[i] + 141;
        extra_field141_0 = other.extra_field141_0 + 141;
        extra_field141_1 = other.extra_field141_1;  // Shallow copy pointer
        extra_field141_2 = other.extra_field141_2 + 141;
        for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType141& operator=(const TestType141& other) {
        if(this != &other) {
            id = other.id + 141;
            for(int i=0; i<157; ++i) unique_data[i] = other.unique_data[i] + 141;
            extra_field141_0 = other.extra_field141_0 + 141;
            extra_field141_1 = other.extra_field141_1;  // Shallow copy pointer
            extra_field141_2 = other.extra_field141_2 + 141;
            for(int i=0; i<4; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType141& other) const { return id < other.id; }
    bool operator==(const TestType141& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 142
struct TestType142 {
    char unique_data[143];
    int id;
    unsigned long long extra_field142_0;
    double extra_field142_1;
    float extra_field142_2;
    int extra_field142_3;
    unsigned short extra_field142_4;
    double padding[2];
    TestType142()
        : id(142), extra_field142_0(142 * 1), extra_field142_1(142 * 2), extra_field142_2(142 * 3), extra_field142_3(142 * 4), extra_field142_4(142 * 5) {
        // Initialize unique_data array
        for(int i=0; i<143; ++i) unique_data[i] = (i+142) % 256;
        for(int i=0; i<2; ++i) padding[i] = 142 + i * 0.1;
    }
    TestType142(const TestType142& other) {
        id = other.id + 142;
        for(int i=0; i<143; ++i) unique_data[i] = other.unique_data[i] + 142;
        extra_field142_0 = other.extra_field142_0 + 142;
        extra_field142_1 = other.extra_field142_1 + 142;
        extra_field142_2 = other.extra_field142_2 + 142;
        extra_field142_3 = other.extra_field142_3 + 142;
        extra_field142_4 = other.extra_field142_4 + 142;
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType142& operator=(const TestType142& other) {
        if(this != &other) {
            id = other.id + 142;
            for(int i=0; i<143; ++i) unique_data[i] = other.unique_data[i] + 142;
            extra_field142_0 = other.extra_field142_0 + 142;
            extra_field142_1 = other.extra_field142_1 + 142;
            extra_field142_2 = other.extra_field142_2 + 142;
            extra_field142_3 = other.extra_field142_3 + 142;
            extra_field142_4 = other.extra_field142_4 + 142;
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType142& other) const { return id < other.id; }
    bool operator==(const TestType142& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 143
struct TestType143 {
    char unique_data[145];
    int id;
    char** extra_field143_0;
    unsigned long extra_field143_1;
    char** extra_field143_2[4];
    char** extra_field143_3;
    unsigned long long extra_field143_4;
    double padding[5];
    TestType143()
        : id(143), extra_field143_0(nullptr), extra_field143_1(143 * 2), extra_field143_3(nullptr), extra_field143_4(143 * 5) {
        // Initialize unique_data array
        for(int i=0; i<145; ++i) unique_data[i] = (i+143) % 256;
        for(int i=0; i<4; ++i) extra_field143_2[i] = nullptr;
        for(int i=0; i<5; ++i) padding[i] = 143 + i * 0.1;
    }
    TestType143(const TestType143& other) {
        id = other.id + 143;
        for(int i=0; i<145; ++i) unique_data[i] = other.unique_data[i] + 143;
        extra_field143_0 = other.extra_field143_0;  // Shallow copy pointer
        extra_field143_1 = other.extra_field143_1 + 143;
        for(int i=0; i<4; ++i) extra_field143_2[i] = other.extra_field143_2[i];
        extra_field143_3 = other.extra_field143_3;  // Shallow copy pointer
        extra_field143_4 = other.extra_field143_4 + 143;
        for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType143& operator=(const TestType143& other) {
        if(this != &other) {
            id = other.id + 143;
            for(int i=0; i<145; ++i) unique_data[i] = other.unique_data[i] + 143;
            extra_field143_0 = other.extra_field143_0;  // Shallow copy pointer
            extra_field143_1 = other.extra_field143_1 + 143;
            for(int i=0; i<4; ++i) extra_field143_2[i] = other.extra_field143_2[i];
            extra_field143_3 = other.extra_field143_3;  // Shallow copy pointer
            extra_field143_4 = other.extra_field143_4 + 143;
            for(int i=0; i<5; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType143& other) const { return id < other.id; }
    bool operator==(const TestType143& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 144
struct TestType144 {
    char unique_data[144];
    int id;
    unsigned long long extra_field144_0;
    char extra_field144_1[5];
    unsigned char extra_field144_2[9];
    double* extra_field144_3[2];
    void* extra_field144_4;
    double padding[2];
    TestType144()
        : id(144), extra_field144_0(144 * 1), extra_field144_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<144; ++i) unique_data[i] = (i+144) % 256;
        for(int i=0; i<5; ++i) extra_field144_1[i] = 144 + i;
        for(int i=0; i<9; ++i) extra_field144_2[i] = 144 + i;
        for(int i=0; i<2; ++i) extra_field144_3[i] = nullptr;
        for(int i=0; i<2; ++i) padding[i] = 144 + i * 0.1;
    }
    TestType144(const TestType144& other) {
        id = other.id + 144;
        for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 144;
        extra_field144_0 = other.extra_field144_0 + 144;
        for(int i=0; i<5; ++i) extra_field144_1[i] = other.extra_field144_1[i];
        for(int i=0; i<9; ++i) extra_field144_2[i] = other.extra_field144_2[i];
        for(int i=0; i<2; ++i) extra_field144_3[i] = other.extra_field144_3[i];
        extra_field144_4 = other.extra_field144_4;  // Shallow copy pointer
        for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType144& operator=(const TestType144& other) {
        if(this != &other) {
            id = other.id + 144;
            for(int i=0; i<144; ++i) unique_data[i] = other.unique_data[i] + 144;
            extra_field144_0 = other.extra_field144_0 + 144;
            for(int i=0; i<5; ++i) extra_field144_1[i] = other.extra_field144_1[i];
            for(int i=0; i<9; ++i) extra_field144_2[i] = other.extra_field144_2[i];
            for(int i=0; i<2; ++i) extra_field144_3[i] = other.extra_field144_3[i];
            extra_field144_4 = other.extra_field144_4;  // Shallow copy pointer
            for(int i=0; i<2; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType144& other) const { return id < other.id; }
    bool operator==(const TestType144& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 145
struct TestType145 {
    char unique_data[164];
    int id;
    long extra_field145_0;
    char random_padding[3];
    TestType145()
        : id(145), extra_field145_0(145 * 1) {
        // Initialize unique_data array
        for(int i=0; i<164; ++i) unique_data[i] = (i+145) % 256;
        for(int i=0; i<3; ++i) random_padding[i] = (145 + i) % 128;
    }
    TestType145(const TestType145& other) {
        id = other.id + 145;
        for(int i=0; i<164; ++i) unique_data[i] = other.unique_data[i] + 145;
        extra_field145_0 = other.extra_field145_0 + 145;
        for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType145& operator=(const TestType145& other) {
        if(this != &other) {
            id = other.id + 145;
            for(int i=0; i<164; ++i) unique_data[i] = other.unique_data[i] + 145;
            extra_field145_0 = other.extra_field145_0 + 145;
            for(int i=0; i<3; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType145& other) const { return id < other.id; }
    bool operator==(const TestType145& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 146
struct TestType146 {
    char unique_data[147];
    int id;
    int* extra_field146_0[5];
    int extra_field146_1;
    float* extra_field146_2[3];
    unsigned char extra_field146_3;
    char* extra_field146_4;
    TestType146()
        : id(146), extra_field146_1(146 * 2), extra_field146_3(146 * 4), extra_field146_4(nullptr) {
        // Initialize unique_data array
        for(int i=0; i<147; ++i) unique_data[i] = (i+146) % 256;
        for(int i=0; i<5; ++i) extra_field146_0[i] = nullptr;
        for(int i=0; i<3; ++i) extra_field146_2[i] = nullptr;
    }
    TestType146(const TestType146& other) {
        id = other.id + 146;
        for(int i=0; i<147; ++i) unique_data[i] = other.unique_data[i] + 146;
        for(int i=0; i<5; ++i) extra_field146_0[i] = other.extra_field146_0[i];
        extra_field146_1 = other.extra_field146_1 + 146;
        for(int i=0; i<3; ++i) extra_field146_2[i] = other.extra_field146_2[i];
        extra_field146_3 = other.extra_field146_3 + 146;
        extra_field146_4 = other.extra_field146_4;  // Shallow copy pointer
    }
    TestType146& operator=(const TestType146& other) {
        if(this != &other) {
            id = other.id + 146;
            for(int i=0; i<147; ++i) unique_data[i] = other.unique_data[i] + 146;
            for(int i=0; i<5; ++i) extra_field146_0[i] = other.extra_field146_0[i];
            extra_field146_1 = other.extra_field146_1 + 146;
            for(int i=0; i<3; ++i) extra_field146_2[i] = other.extra_field146_2[i];
            extra_field146_3 = other.extra_field146_3 + 146;
            extra_field146_4 = other.extra_field146_4;  // Shallow copy pointer
        }
        return *this;
    }
    bool operator<(const TestType146& other) const { return id < other.id; }
    bool operator==(const TestType146& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 147
struct TestType147 {
    char unique_data[158];
    int id;
    float* extra_field147_0;
    unsigned short extra_field147_1;
    double* extra_field147_2[3];
    char random_padding[2];
    TestType147()
        : id(147), extra_field147_0(nullptr), extra_field147_1(147 * 2) {
        // Initialize unique_data array
        for(int i=0; i<158; ++i) unique_data[i] = (i+147) % 256;
        for(int i=0; i<3; ++i) extra_field147_2[i] = nullptr;
        for(int i=0; i<2; ++i) random_padding[i] = (147 + i) % 128;
    }
    TestType147(const TestType147& other) {
        id = other.id + 147;
        for(int i=0; i<158; ++i) unique_data[i] = other.unique_data[i] + 147;
        extra_field147_0 = other.extra_field147_0;  // Shallow copy pointer
        extra_field147_1 = other.extra_field147_1 + 147;
        for(int i=0; i<3; ++i) extra_field147_2[i] = other.extra_field147_2[i];
        for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType147& operator=(const TestType147& other) {
        if(this != &other) {
            id = other.id + 147;
            for(int i=0; i<158; ++i) unique_data[i] = other.unique_data[i] + 147;
            extra_field147_0 = other.extra_field147_0;  // Shallow copy pointer
            extra_field147_1 = other.extra_field147_1 + 147;
            for(int i=0; i<3; ++i) extra_field147_2[i] = other.extra_field147_2[i];
            for(int i=0; i<2; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType147& other) const { return id < other.id; }
    bool operator==(const TestType147& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 148
struct TestType148 {
    char unique_data[160];
    int id;
    double* extra_field148_0[1];
    unsigned long extra_field148_1;
    TestType148()
        : id(148), extra_field148_1(148 * 2) {
        // Initialize unique_data array
        for(int i=0; i<160; ++i) unique_data[i] = (i+148) % 256;
        for(int i=0; i<1; ++i) extra_field148_0[i] = nullptr;
    }
    TestType148(const TestType148& other) {
        id = other.id + 148;
        for(int i=0; i<160; ++i) unique_data[i] = other.unique_data[i] + 148;
        for(int i=0; i<1; ++i) extra_field148_0[i] = other.extra_field148_0[i];
        extra_field148_1 = other.extra_field148_1 + 148;
    }
    TestType148& operator=(const TestType148& other) {
        if(this != &other) {
            id = other.id + 148;
            for(int i=0; i<160; ++i) unique_data[i] = other.unique_data[i] + 148;
            for(int i=0; i<1; ++i) extra_field148_0[i] = other.extra_field148_0[i];
            extra_field148_1 = other.extra_field148_1 + 148;
        }
        return *this;
    }
    bool operator<(const TestType148& other) const { return id < other.id; }
    bool operator==(const TestType148& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 149
struct TestType149 {
    char unique_data[154];
    int id;
    long extra_field149_0;
    char extra_field149_1[3];
    void* extra_field149_2;
    double extra_field149_3;
    char** extra_field149_4[1];
    double padding[3];
    TestType149()
        : id(149), extra_field149_0(149 * 1), extra_field149_2(nullptr), extra_field149_3(149 * 4) {
        // Initialize unique_data array
        for(int i=0; i<154; ++i) unique_data[i] = (i+149) % 256;
        for(int i=0; i<3; ++i) extra_field149_1[i] = 149 + i;
        for(int i=0; i<1; ++i) extra_field149_4[i] = nullptr;
        for(int i=0; i<3; ++i) padding[i] = 149 + i * 0.1;
    }
    TestType149(const TestType149& other) {
        id = other.id + 149;
        for(int i=0; i<154; ++i) unique_data[i] = other.unique_data[i] + 149;
        extra_field149_0 = other.extra_field149_0 + 149;
        for(int i=0; i<3; ++i) extra_field149_1[i] = other.extra_field149_1[i];
        extra_field149_2 = other.extra_field149_2;  // Shallow copy pointer
        extra_field149_3 = other.extra_field149_3 + 149;
        for(int i=0; i<1; ++i) extra_field149_4[i] = other.extra_field149_4[i];
        for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
    }
    TestType149& operator=(const TestType149& other) {
        if(this != &other) {
            id = other.id + 149;
            for(int i=0; i<154; ++i) unique_data[i] = other.unique_data[i] + 149;
            extra_field149_0 = other.extra_field149_0 + 149;
            for(int i=0; i<3; ++i) extra_field149_1[i] = other.extra_field149_1[i];
            extra_field149_2 = other.extra_field149_2;  // Shallow copy pointer
            extra_field149_3 = other.extra_field149_3 + 149;
            for(int i=0; i<1; ++i) extra_field149_4[i] = other.extra_field149_4[i];
            for(int i=0; i<3; ++i) padding[i] = other.padding[i] + 0.01;
        }
        return *this;
    }
    bool operator<(const TestType149& other) const { return id < other.id; }
    bool operator==(const TestType149& other) const { return id == other.id; }
};

#endif
#if NUM_TYPES >= 150
struct TestType150 {
    char unique_data[169];
    int id;
    unsigned short extra_field150_0;
    void* extra_field150_1;
    unsigned int extra_field150_2;
    char random_padding[1];
    TestType150()
        : id(150), extra_field150_0(150 * 1), extra_field150_1(nullptr), extra_field150_2(150 * 3) {
        // Initialize unique_data array
        for(int i=0; i<169; ++i) unique_data[i] = (i+150) % 256;
        for(int i=0; i<1; ++i) random_padding[i] = (150 + i) % 128;
    }
    TestType150(const TestType150& other) {
        id = other.id + 150;
        for(int i=0; i<169; ++i) unique_data[i] = other.unique_data[i] + 150;
        extra_field150_0 = other.extra_field150_0 + 150;
        extra_field150_1 = other.extra_field150_1;  // Shallow copy pointer
        extra_field150_2 = other.extra_field150_2 + 150;
        for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
    }
    TestType150& operator=(const TestType150& other) {
        if(this != &other) {
            id = other.id + 150;
            for(int i=0; i<169; ++i) unique_data[i] = other.unique_data[i] + 150;
            extra_field150_0 = other.extra_field150_0 + 150;
            extra_field150_1 = other.extra_field150_1;  // Shallow copy pointer
            extra_field150_2 = other.extra_field150_2 + 150;
            for(int i=0; i<1; ++i) random_padding[i] = other.random_padding[i];
        }
        return *this;
    }
    bool operator<(const TestType150& other) const { return id < other.id; }
    bool operator==(const TestType150& other) const { return id == other.id; }
};

#endif